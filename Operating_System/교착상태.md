# 교착상태(Deadlock)

> 정적인 상태의 프로그램이, 자원을 할당받아 동적인 프로세스가 된다. 하지만 CPU, 메모리 등의 자원의 양은 제한되어있기 때문에 원하는 모든 프로세스를 무제한으로 동시에 실행시키는 것은 불가능하다. 자원이 이미 다른 프로세스에 의해 점유된 상태에서, 해당 자원을 다른 프로세스들이 너도나도 요구하게 된다면, 프로세스들이 실행되지 못하고 자원 할당을 한없이 기다리는 상태에 놓이게 될 것이다. 
>
> 이번에는 이러한 '교착상태' 의 개념과 교착상태를 어떻게 해결하는 지에 대해 살펴보도록 한다.


![Deadlock - an overview | ScienceDirect Topics](https://ars.els-cdn.com/content/image/3-s2.0-B0122274105008516-gr6.gif) ![Detect Deadlocks in old NAVs - Roberto Stefanetti Blog MVP, MCT, MIE](https://i1.wp.com/robertostefanettinavblog.com/wp-content/uploads/2018/04/image022.jpg?resize=302%2C219)

### 교착상태의 개념과 발생 조건
```
상호배제 원칙으로 인해 서로의 공유자원을 프로세스들이 요구함으로써 무한정 대기하는 상황
```
- 둘 이상의 프로세스가 자원을 점유한 상태에서, 서로 다른 프로세스가 점유중인 자원을 요구하면서 무한정 기다리고 있는 현상을 말함

- 이는 __`상호배제(Mutual Exclusion)`__ 로 인해 나타나는 문제점으로, 상호배제는 __여러 프로세스가 공유하는 자원에 대해서, 특정 시점에서 한 개의 프로세스만이 공유자원을 점유할 수 있는 원칙__ 을 말함

  - 이러한 공유자원 영역을 __`임계영역(Critical Section)`__ 이라고 하며, 상호배제는 임계영역을 유지하는 기법인 셈
  - 더 나아가, 결국 상호배제로 인해 두 개이상의 프로세스를 한 시점에서 동시에 처리할 수 없는 경우, 프로세스 실행 순서를 명확히 하는 것을 __`동기화(Synchronization)`__ 라고 부르는 것

  

- 교착상태가 일어나기 위한 필요 조건은 4가지로, 여기서 하나라도 충족되지 않으면 교착상태가 발생하지 않음

  (또한 4가지 조건을 모두 충족했다고 해서 반드시 교착상태가 일어나는 것도 아님)

  - __상호배제(Mutual Exclusion)__

    - 한 번에 한 개의 프로세스만이 공유자원을 점유해야 함

  - __점유대기(Hold and Wait)__

    - 어떤 프로세스가 자원을 할당받아 배타적으로 점유하는 상황에서, 다른 프로세스가 자원을 사용하고자 할 경우에는 점유된 자원이 해제되기를 기다려야 함

  - __비선점(Non-preemption)__

    - 어떤 프로세스에 할당된 자원은, 해당 프로세스가 자원을 스스로 반환하기 전까지는 제거되지 않음
    - 다시 말해, 프로세스 종료 후에만 해제될 수 있으며 타의에 의한 해제는 불가능한 것

  - __환형대기(Circular Wait)__

    ![교착상태](https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F2505A94B595D1A332E)

    - 프로세스의 자원 점유 및 점유된 자원의 요구 관계가 환형을 이루면서 대기하는 조건을 말함
    - 자원을 점유하면서 원형 구조에서 자신의 앞 혹은 뒤에 있는 프로세스의 자원을 요구하는 상황

.

### 교착상태의 해결

- 교착상태 처리 전략은 크게 __`방지`__ , __`회피`__ , __`탐지 및 복구`__ 의 세가지로 나눌 수 있음

- __`방지`__ : 교착상태가 발생하기 위한 4가지 필요 조건 중 적어도 하나 이상이 발생하지 않도록 함

  - __상호배제 조건의 제거__ 

    - 공유 가능한 자원의 경우 상호배제가 필요하지 않지만, 그렇지 않다면 반드시 상호배제를 따라야 하기 때문에 사실상 불가능한 전략임

    

  - __점유 대기 조건의 제거__

    - 점유 대기를 없애려면 프로세스가 자원을 요청할 때, 해당 프로세스는 __어떠한 자원도 할당받지 않은 상태__ 로 만들면 됨

    - 필요한 모든 자원을 한꺼번에 요구하여 할당받도록 할 수 있음

      - 나중에 사용할 자원까지 우선 다 가지고 있기 때문에, 전체적인 자원의 이용도 측면에서 비효율적

    - 혹은, 자원을 부분적으로 요청하여 할당받도록 하되, 추가 요청시에는 이전에 가지고 있던 자원을 모두 해제하도록 할 수도 있음

      - 빈번히 사용되는 자원의 경우, 다른 자원 요청을 위해 잠시 반납한 순간 해당 자원이 다른 프로세스에 할당되버리는 문제가 발생할 수 있음
      - __`기아상태(starvation)`__ 이 발생해버리는 것

      

  - __비선점 조건의 제거__

    - 우선 어떤 자원을 점유하고 있는 프로세스가 다른 자원을 요청했을 때, __즉시 할당받지 못하는 경우에 점유중이던 자원을 해제하도록__ 할 수 있음

      - 이후 해제된 자원을 포함하여 모든 필요한 자원이 사용 가능해질 경우에 프로세스가 재개됨

    - 혹은 프로세스가 어떤 자원을 요청했을 때, __가용 여부를 조사하여__ 가용상태이면 할당하고 그렇지 않은 경우에는 __해당 자원이 다른 자원을 할당받기 위해 대기중인 프로세스에 할당되어 있는 지를 조사하여,__ 대기중인 프로세스로부터 자원을 선점하도록 할 수도 있을 것

      - 이 경우에는 자원이 가용상태가 아니거나, 실행중인 프로세스에 할당된 경우이면 자원을 요청한 프로세스는 반드시 대기해야 함

      

  - __환형 대기 조건의 제거__

    - 순환 형태로 프로세스가 자원을 요구하며 대기하지 않고, __선형으로 프로세스가 자원을 요구하는 형태__ 가 되도록 함
    - 자원에 고유번호를 할당하고, 프로세스가 특정 번호를 기준으로 오름차순으로 자원을 요청하도록 할 수 있음
    - 혹은, 프로세스가 특정 자원을 요구할 때, 요구할 자원의 일련번호보다 큰 번호를 받은 자원은 모두 해제하도록 할 수도 있음
    - 이 방식은 결국 일련번호를 부여하기 위한 함수가 어떻게 정의되냐에 따라 성능이 좌우됨
      - 보통, 먼저 사용되야 하는 자원일수록 작은 일련번호를 부여

