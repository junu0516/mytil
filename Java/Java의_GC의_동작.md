# GC의 개념과 Java에서의 GC 동작 원리

​    ![garbage collection in java](https://techblogstation.com/wp-content/uploads/2019/09/garbage-collection-1024x477.png)

###  프로그래밍에서의 GC의 개념

- 동적으로 할당된 메모리 영역 중, 사용되지 않는 영역을 해제시키는 기법

- 보통 아래의 2가지 가정(Weak Generational Hypothesis)에 기반함

  ```
  1. 대부분의 객체는 생성 후 곧 접근 불가능한(Unreachable) 상태가 됨.
  2. 오래된 객체가 젊은 객체를 참조하는 경우는 적음
  ```

- 여기서 사용할 수 없는 영역은 그 어떤 변수도 가리키지 않는 영역을 의미함
  - 장점 : __포인터가 잘못된 값을 가리키거나, 메모리 누수로 인한 프로세스 장애를 방지할 수 있음__
  
    > __메모리 누수__
    >
    > 필요 없는 메모리 공간이 반납되지 않고 그대로 남아있는 버그를 가리킴. 메모리 누수가 잦을 경우 접근 가능한 메모리 공간의 부족으로 인해 프로그램이 중단될 수 있음

- 단점 : __GC 자체를 수행하기 위한 비용이 수반되며 수행 시점이 예측 불가능함__
  - 우선, 어떤 메모리를 해제 할 지 결정하는 데 비용이 듦
  - GC가 일어나는 타이밍이나, 관련 스레드의 점유시간 및 메모리 해제 시점을 정확히 알기 힘듦

- GC를 구현하는 기법은 다양하나, 보통 자바나 C#과 같은 언어는 그 자체로 GC를 포함하기 때문에 메모리 관리를 크게 신경쓰지 않아도 됨



### 포인터의 추적 방식

> 대부분의 경우 GC는 포인터 추적 방식을 사용하며, 이는 한개 이상의 변수가 접근 가능한 메모리를 사용 가능한 것으로 간주하고, 그 밖의 메모리는 해제하는 방식을 일컫음

- __Mark and Sweep__

  - 가장 단순한 기법으로, 각 메모리 할당 여역에 1비트의 표시용 메모리를 남겨둔 후, 모든 변수가 가리키는 영역과, 이들이 가리키는 또다른 영역 모두를 '사용중'으로 표시함( __Mark__ )
  - 표시가 끝나면, 사용중 표시가 없는 메모리는 모두 접근 불가능한 메모리 영역으로 간주되며, 이러한 영역은 쓸기( __Sweep__ ) 단계에서 모두 해제됨
  - 표시 단계에서 전체 시스템의 실행이 정지된다는 단점이 있음(병행 수행 불가능)

  

- __삼색 표시 기법__

  - Mark and Sweep을 보완한 기법으로, __표시 단계에서 총 3가지 종류의 표시로 메모리를 구분__
    - 프로그램 실행 중에도 병행 가능하며, 주기적인 수집 또한 가능함
  - 흰색은 접근 불가능한 객체를, 회색은 접근 가능하나 아직 검사되지 않은 객체를, 검은색은 해당 객체가 속한 영역에서 가리키는 객체가 흰색 객체를 가리키지 않음을 의미함
  - 처음 알고리즘 시작시 변수들이 가리키는 객체들은 모두 회색으로 표시되며, 이 외의 객체는 모두 흰색으로 표시함
  - 이후 회색 객체 중 하나를 다시 검은색으로 표시하고, 해당 객체가 가리키는 다른 모든 객체를 다시 회색으로 표시함
  - 위의 과정을 반복하면 결국 회색 객체가 하나도 남지 않는 순간에 도달하게 되며, 마지마겡 남은 흰색 객체는 접근 불가능한 객체로 간주되므로 모두 해제됨

  

- __객체 이동 기법__

  - 해제할 객체의 표시가 완료된 후, 해제되지 않은 객체를 다른 영역으로 복사하는 기법
  - 주기적인 복사로 인해 포인터의 내용이 바뀌기 때문에 __포인터 관련 연산을 활용하기 애매함__
  - 하지만 해제되지 않은 객체를 따로 복사했기 때문에, 해제된 영역과 사용중인 영역의 표시를 위한 작업이 필요 없기 때문에 결과적으로 __할당과 해제가 빠르게 이루어짐__
  - 또한 할당된 메모리들이 __단편화__ 되는 것을 방지할 수 있음

  

- __세대 단위 쓰레기 수집__

  - __자바의 GC에 활용되는 방식__
  - __새롭게 할당된 영역일수록 금방 해제될 확률이 높다는 가정__ 하에, 객체를 할당된 시간에 따라 세대별로 구분하여 서로 다른 메모리 영역에 객체를 할당하는 방식
  - 한 세대의 영역이 꽉 차면 해당 영역에서 살아남은 객체를 오래된 세대 영역으로 옮김



### 자바에서의 GC 동작 원리

- 우선 자바 코드에서 쓰레기(Garbage)의 발생 상황은 아래와 같음

  - 하나의 변수에 객체를 할당한 후 해제했다가 다시 새로운 객체를 할당한 것
  - 제일 먼저 생성된 __`ExampleObject`__ 객체는 __`example = null;`__ 의 선언 이후 더 이상 참조되는 변수가 없기 때문에 쓰레기로 간주됨
  - 만일 GC가 없다면 이러한 쓰레기가 많아짐에 따라 프로그램의 성능이 크게 저하될 것임

  ```java
  ExampleObject example = new ExampleObject(); //새로운 객체의 생성
  example.executeMethod(); //메소드 수행
  example = null; //변수에의 할당 해제
  
  example = new ExampleObject(); //다시 새로운 객체를 생성해서 변수에 할당
  example.executeMethod(); //새로운 메소드 수행
  ```

   

- __`Weak Generational Hypothesis`__ 에 따라, 자바의 GC에서의 Heap 메모리 구조는 Young & Old의 두 영역으로 나뉨

  > __Heap Area__
  >
  > new를 통해 선언된 객체 혹은 배열이 저장되는 공간	

- __Young 영역__

  - 새롭게 생성된 객체가 할당되는 영역이며, 대부분의 객체는 생성 후 금방 접근 불가능한 상태가 되기 때문에 이곳에 머무르는 시간은 상대적으로 짧음
  - Young 영역은 다시 1개의 __`Eden 영역`__ rhk, 2개의 __`Survivor 영역`__ 으로 나뉨
    - __Eden 영역__ : 새로 생성된 객체가 할당되는 영역
    - __Survivor 영역__ : 최소 1번 이상의 GC에서 살아남은 객체가 위치하는 영역
  - Young 영역에서의 GC를 __`Minor GC`__ 라고 부름

- __Old 영역__

  - Young 영역에서 여전히 접근 가능한 상태인 객체가 이동(=복사)되는 영역

  - Old 영역에서의 GC를 __`Major GC`__ 혹은 __`Full GC`__ 라고 부름

    

- 일단, Young & Old 영역은 서로 다른 메모리 구조이지만 기본적으로 아래의 2가지 과정을 공통적으로 거침

  - __Stop the World : GC 실행을 위해 일단 JVM이 어플리케이션의 실행을 잠시 멈춤(스레드 작업 중단)__
  - __Mark and Sweep : 사용되는 메모리와 사용되지 않는 메모리를 식별 후, 사용되지 않는 메모리를 해제__

- 이후 Minor GC와 Major GC의 동작 방식은 아래와 같음



- __Minor GC의 동작 방식__

  ![img](https://blog.kakaocdn.net/dn/Cyho2/btqURvZRql6/4a7u6mMGofkpuURKQz0RT1/img.png)

  1. 객체가 새롭게 생성되면 우선 Eden 영역에 할당됨
  2. Eden 영역이 가득 차면, Minor GC가 발생하여 해제되지 않고 Eden에 존재한 객체를 1개의 Survivor 영역으로 옮김
  3. 위의 두 과정을 반복하다가 Survivor 영역이 가득차면, Survivor 영역에서 GC로부터 살아남은 객체를 다른 Survivor 영역으로 이동시킴
     - 따라서 2개의 Survivor 영역 중 하나는 반드시 사용중인 상태여야 함
     - 만일 2개의 Survivor 모두에 데이터가 있거나, 아무 Survivor도 사용중이 아니면 해당 시스템은 정상적인 상황이 아닌 것
  4. 이를 반복 후, 계속해서 살아남는 객체는 Old 영역으로 이동하게 되는 것( __`Promotion`__ )
     - 여기서 Minor GC에서 객체가 살아남은 횟수를 __`age`__ 라고 하며, age는 __`Object Header`__ 에 기록됨
     - 이후, age가 얼마나 큰 지를 보고 Promotion 여부를 결정하게 됨



- __Major GC의 동작 방식__
  - Minor GC에서 Promotion된 객체들이 늘어나 Old 영역이 가득차면 Major GC가 일어남
  - Old 영역을 스캔하여 각 객체들의 참조 여부를 표시한 후, 참조되지 않은 객체는 제거함
  - __Minor GC__ 에 비해 속도가 상대적으로 느리며 성능에 더 큰 영향을 끼침
    - Major GC가 일어나는 동안에는 어플리케이션 자체가 멈추기 때문
