## JVM의 구조와 동작

![img](https://upload.wikimedia.org/wikipedia/commons/d/dd/JvmSpec7.png)



### JVM(Java Virtual Machine)의 개념

- 자바 바이트코드를 실행하는 주체이며, 자바 어플리케이션과 운영체제 간의 중개 및 메모리 관리의 역할을 수행

  - 자바 어플리케이션의 실행이 __다양한 운영체제 환경에 구애받지 않도록 함__
  - __`Garbage Collection(쓰레기 수집)`__ 을 통해  메모리를 효율적으로 사용

- __자바 프로그램 실행 원리__

  ```
  1. 프로그램 실행 후, JVM이 운영체제로부터 메모리(자원)를 할당받으면, JVM은 용도에 맞게 메모리를 나눠서 관리
  2. 자바 컴파일러(javac)가 자바 코드(.java)를 읽어, 자바 바이트코드(.class)로 변환(컴파일) 
  3. 클래스 로더(Class Loader)가 생성된 class 파일들을 JVM에 로딩
  4. 로딩된 class 파일이 실행 엔진(Execution Engine)을 통해 기계가 읽어들일 수 있도록 해석됨
  5. 해석된 바이트코드는 런타임 영역(Runtime Data Area)에 배치되어, 실질적으로 자바 어플리케이션이 수행됨
  ```

- 자바 프로그램의 실행 과정송에서 JVM은 필요에 따라 __`GC(쓰레기 수집)`__ 나 __`스레드 동기화(Thread Synchronization)`__ 와 같은 작업을 수행



### JVM의 구조

- __Class Loader(클래스 로더)__ 
  - 런타임 시점에 동적으로 JVM에 자바 컴파일러(javac)에 의해 컴파일된 class 파일을 로드하며, Runtime Data Area에 클래스 파일을 적재
  - 쉽게 말해, 컴파일된 클래스 파일들을 실행 시점에 동적으로 메모리에 적재하는 것
  - 이 외에도, 사용하지 않는 클래스는 메모리에서 삭제하는 역할도 수행(효율성 제고)
- __Execution Engine(실행 엔진)__
  - 클래스 로더에 의해 적재된 클래스 파일을 실행시키는 역할을 담당
  - 클래스 로더가 후술할 Runtime Data Area에 바이트 코드를 배치시키면, 이것이 실행 엔진에 의해 실행됨
  - __`바이트 코드`__ 는 기계어가 아닌, 인간이 보기 편한 형태의 언어이기 때문에, 실행 엔진은 바이트 코드를 기계어로 해석해야 함
    - __인터프리터 방식__ 
      - 바이트 코드를 명령어 단위로 읽어서 실행시키는 방식
      - 한줄 한줄 수행하기 때문에, 그만큼 느리다는 단점이 있음
    - __JIT(Just in Time) 방식__ 
      - 인터프리터 방식의 단점을 보완하고자 도입된 방식
      - 처음에는 인터프리터 방식으로 실행하다가 __적절한 시점에 바이트코드 전체를 네이티브 코드(기계어)로 변환시켜, 이후부터는 더 이상 인터프리팅을 수행하지 않음__
      - 해석된 네이티브 코드는 캐시에 보관되기 때문에, 한 번 컴파일된 코드는 그만큼 빠르게 수행된다는 이점이 있음
      - 단, 전체를 컴파일하는 방식은 당연히 일부만을 컴파일하는 것보다 느리기 때문에 짧은 코드를 한 번만 수행하는 경우에는 오히려 인터프리터 방식이 나을 수도 있음
- __Garbage Collector__
  - Heap 영역에 존재하는 객체들 중, __참조되지 않는(=불필요하다고 간주되는) 객체들을 메모리에서 제거하는 역할 수행__
  - 메모리 사용의 효율성을 위한 것이며, 동작 시간이 일정하게 정해져 있지 않음
  - Garbage Collecting을 수행하는 동안에는, 관련 스레드를 제외한 __나머지 스레드가 일시정지__ 상태가 됨
    - 이로 인한 프로세스의 장애 발생 가능성에 유의
- __Runtime Data Area__
  - 프로그램(=로딩된 클래스들)의 실질적인 수행을 위해, 운영체제로 부터 할당받은 메모리 공간이며 크게 5가지 영역으로 나뉨
    - __PC Register__
      - 스레드가 생성될 때마다 생성되는 공간으로 실행중인 스레드의 주소와, 수행하고 있는 명령을 저장
    - __Stack Area(스택 영역)__
      - 각종 변수(지역변수, 파라미터 등) 및 기본 자료형 등이 저장되는 공간
      - 정확히는, 프로그램의 실행 과정에서 임시로 할당된 후 메소드를 빠져나가면 바로 소멸되는 특성의 데이터가 저장되는 공간
      - int a = 10; 이 선언될 경우, 변수 a를 위한 메모리 공간이 할당되고 그 안에 값 10이 들어가는 것
      - 메소드를 호출할 때마다 해당 메소드를 위한 스택 영역이 생성되며, 메소드 수행이 끝나면 해당 영역은 제거됨
    - __Heap Area__
      - new를 통해 선언된 객체나 배열이 저장되는 공간
      - 후술할 Method Area에 로드된 클래스들만이 생성될 수 있으며, GC(Garbage Collector)는 여기서 참조되지 않는 객체를 제거함
    - __Method Area__
      - __`Static Area`__ ,혹은 __`Class Area`__ 라고도 하며, 로드된 클래스가 처음 메모리에 적재될 때 초기화되는 대상을 위한 공간
      -  보통 자바 프로그램은 __`main() 메소드`__ 의 호출에서 시작하여, 인스턴스에 속한 메소드들의 연속적인 호출을 통해 흐름이 이어짐
      - 따라서 대부분의 클래스는 메소드들의 집합이기 때문에 거의 모든 바이트코드가 올라간다고 봐도 됨
        - Method Area가 클래스를 위한 공간이고, Heap Area는 선언된 객체를 위한 공간으로, 둘을 서로 구분
        - Method Area 역시 Garbage Collector의 관리 대상에 포함됨
      - Method Area에 올라가는 정보의 종류
        - __Field Information__ : 필드상의 멤버변수의 이름, 데이터 타입, 접근 제어자 등
        - __Method Information__ : 메소드의 이름, 리턴 타입, 매개변수, 접근제어자 등
        - __Type Information__ :  class & interface 여부, super class의 이름 등
        - __Constant Pool__ : 상수로 선언된 값들이 저장되며 중복을 방지
    - __Native Method Stack__ 
      - 자바 파일이 컴파일된 후 생성된 바이트 코드가 아닌 기계어로 작성된 프로그램을 실행시키는 영역
        - 쉽게 말해, 자바가 아닌 다른 언어로 작성된 네이티브 코드를 위한 메모리 공간
      - __`Java Native Interface`__ 를 통해 바이트코드로 전환되어 저장되며, 커널이 해당 공간을 통해 독자적으로 C나 C++과 같은 언어로 만들어진 프로그램을 실행시킴

```
보통 스레드 생성시 Method Area와 Heap Area는 모든 스레드가 공유하며, 나머지 영역은 각각의 스레드마다 개별 할당되고 공유되지 않음
```





