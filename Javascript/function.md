# 함수, 콜백함수, 클래스

> 자바스크립트 함수 호출 원리에 대해서 다시 한 번 정리해보자 ..  

`

### 1. 자바스크립트 function

- (정말 당연한 이야기지만) 반복적으로 사용되는 로직을 별도의 함수로 만들어서, 코드의 재사용성을 높이고자 사용하는 것

- __`function`__ 은 __`let`__ 이나 __`const`__ 와 같이 함수를 의미하는 자바스크립트 키워드임

- 함수를 선언하게 되면 함수의 코드블럭 __`{ }`__ 내에 선언된 코드들은 별도의 메모리 공간에 저장됨

  - 함수명은 함수가 위치한 메모리 공간을 가리키는 레퍼런스로 별도의 공간에 위치함
  - 변수 - 객체 의 할당과 유사하다고 보면 됨

- 아래와 같이 변수에 함수를 할당하게 되면?

  - add 함수를 가리키는 레퍼런스로, 변수 fn이 또 다른 메모리 공간에 위치하게 됨
  - 따라서 변수만 가지고 함수를 호출할 수 있음

  ```javascript
  function add(a,b){
      return a+b;
  }
  const fn = add; //함수를 변수에 할당
  const result = fn(1,2);
  console.log(result); //add(1,2)와 동일한 값이 출력됨을 확인
  ```

- 아래와 같이 함수를 파라미터로 전달할 수도 있음

  ```javascript
  function outerFn(innerFn){
      const result = innerFn();
      console.log(result);
  }
  
  outerFn(function(){
     let a = 2;
     let b = 3;
     return a+b;
  }); //5를 리턴하는 함수를 파라미터로 받아서, 이를 콘솔에 출력
  ```

`

### 2. 콜스택, 메모리힙(Call Stack & Memory Heap)

#### 	2-1 메모리 구조

![컴퓨터구조_3주차_메모리구조와 레지스터](https://blog.kakaocdn.net/dn/oBaWX/btqEmpndWpp/nFJMVwNuHjc2bKO4G5Uqzk/img.png)

- 위에서 언급한 함수 및 변수가 저장되는 __메모리 공간__ 에 대해 좀 더 구체적으로 알아보자

  ```
  JVM의 메모리 구조 개념과 유사하다!
  ```

- 메모리 구조에서, 우선 함수의 코드블록 내에 선언된 코드들은 __코드 영역(Code Area)__ 에 저장됨

  - 함수, 상수, 제어문 등이 여기에 저장되는 것

- 여러 변수들 중에서도 전역 변수나 정적(Static) 변수들은 __데이터 영역(Data Area)__ 에 저장됨

  - 자바의 Static Variable과 마찬가지로, 이곳에 저장된 데이터들은 프로그램 시작시 메모리에 올라갔다가 종료시 소멸됨(생명주기)

- 함수의 파라미터와, 코드블록 내부에 선언된 로컬 변수들은 모두 __스택 영역(Stack Area)__ 에 저장됨

  - 자바스크립트의 __`Call Stack`__ 이 이에 해당하며, __`Call Stack`__ 의 경우에는 정적 변수들 중에서 간단한 값만 할당된 변수도 여기에 저장됨
  - 이곳에 저장된 변수들의 생명주기는 함수의 호출-실행 완료에 좌우됨

- 변수가 가리키는 객체나 배열과 같은 것들은 __힙 영역(Heap Area)__ 에 저장되며, 이는 대부분 프로그래머가 직접 선언하기 때문에 스택 영역과 달리 런타임 시점에 결정됨

`

- __힙 영역의 경우 낮은 주소 위치에서 높은 주소 위치 방향으로 쌓이고 스택 영역은 높은 주소 위치에서 낮은 주소 위치 방향으로 쌓임__
  - 이는 다시 말하면 비정상적으로 데이터가 무한하게 쌓이면 어느 순간 두 공간이 서로 충돌할 수 있음을 의미함
  - 잠시 자바에 대해 얘기해보면, 재귀호출이 무한하게 발생할 때 나타나는 __`StackOverflowException`__ 가 바로 위의 충돌 상황이 발생할 때 나타나는 예외임
  - 함수가 호출될 때마다 사용되는 지역변수 및 파라미터가 스택 영역에 쌓이기 때문에 그 어떤 함수도 종료되지 않는 무한 재귀 호출이 발생하면 자연스레 컴파일 시점에 정해진 스택 사이즈를 넘어서게 되는 것

`

#### 	2-2 콜스택(Call Stack)

![What is the different between stack and call stack in Javascript? - Stack  Overflow](https://i.stack.imgur.com/xAQPR.png)

- 앞서 언급한 __`콜스택(Call Stack)`__ 은 코드 실행시 실행 기록, 순서를 저장할 데이터 자료 구조를 의미함

  ``` javascript
  function foo(){
      foo(); //재귀 호출
  }
  foo(); //foo 함수 호출
  ```

  - 위의 그림대로, foo() 함수를 계속 호출하게 되면 스택에 함수가 계속 쌓이면서 결과적으로 _아래와 같은 스택 사이즈 초과 오류 관련 메시지를 확인하게 될 것

  ```
  Uncaught RangeError : Maximum call stack size exceeded
  ```

- 자바스크립트는 싱글 스레드로 된 프로그래밍 언이이기 때문에, 한 번에 하나의 일(Task)만 처리하는 구조임

  - 자바와 같이 멀티 스레딩 환경에서 고려해야 할 여러 요소들을 신경쓰지 않아도 되지만, 하나의 함수 처리에 문제가 생기면 다른 함수의 실행에도 중대한 결함을 불러일으킬 수 있음

- 이런 상황에서 흔히 쓰이는 해결책이 바로 __`비동기 콜백(Asynchronous callback)`__ 임

`

### 3. 비동기 콜백

![img](https://t1.daumcdn.net/cfile/tistory/99A7234F5C321A7F2B)

- 자바스크립트에서 비동기처리를 한다는 것은, 특정 코드의 실행이 끝나기 전에 다른 코드를 실행하는 것을 의미함

- 대표적으로 __`ajax`__ 를 제이쿼리로 호출하는 것이 비동기 호출로 이루어져있음

  - 앞서 언급한 싱클 스레드라는 자바스크립트 특성상 비동기 통신의 성공/실패 여부와 관계 없이 다른 코드가 호출되야 하는 상황을 위한 것
  - 이 외에도 __`DOM Event`__ , __`setTimeout`__ 등도 모두 비동기로 호출되는 함수임

- 위의 그림으로 보면,  비동기 함수의 처리는 아래와 같은 과정을 거치게 됨

  - 비동기 코드가 실행되면 콜스택에 비동기 함수가 들어감
  - 이후 함수가 실행되면 Web API를 호출하며, Web API는 함수를 콜백 큐에 넣음
    - 예를 들어 __`setTimeout(()=>foo(),1000);`__ 이라고 하면, Web API는 1초간 대기 후 실행시킬 foo 함수를 콜백 큐에 넣는 것
  - 이후 콜백 큐는 콜스택이 비는 시점에 이벤트 루프를 돌리며, 이벤트 루프는 스택이 비는 시점에 콜백을 실행시킴

  

