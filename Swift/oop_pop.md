

# OOP와 POP의 차이

> 간단히 OOP 패러다임의 특징을 살펴보고,
>
> POP가 어떤 식으로 OOP의 한계를 보완하는 지 살펴본다.

## 1. Object Oriented Programming

- 간단히 말해서, 컴퓨터 프로그램을 단순한 명령어의 모음으로 보지 않고, __여러 개의 독립된 단위로서의 객체의 모임__ 으로 파악하고자 하는 패러다임
- 여기서 각각의 __`객체`__ 는 서로 간에 메시지를 주고받고 내부에서 데이터를 처리할 수 있음
- 큰 덩어리를 작은 덩어리로 쪼개기 보다는, 작은 덩어리에 해당하는 개별 객체를 만들고 객체들을 조합해서 큰 덩어리의 문제를 해결하는 접근방식이 가능함
- 객체지향 설계에서 중심이 되는 키워드는 기능이 아닌 __`객체`__ 이며, 이는 다시 말해 __`어떤 기능을 어떤 절차로 구현할 것인가?`__ 와 같은 관점으로 접근하는 것이 아니라 __`어떤 객체에게 어떤 일(혹은 책임)을 부여할 것인가?`__ 의 관점으로 접근하는 것을 의미함
- __`Messaging`__ : 객체들이 서로 간에 __`메시지를 주고 받는 행위`__ 를 통해 소통함으로써 객체들 간의 조합이 실현되며, 다른 객체의 데이터 혹은 메소드 실행이 필요하면 메시지를 통해 요청하고, 요청을 받는 객체는 내부에서 요청에 대한 처리를 스스로 선택

### OOP의 주요 특징

#### 1) 추상화

- 여러 객체의 공통적인 특징이나 행위를 도출해서, 객체의 '틀'에 해당하는 __`클래스`__ 를 정의하는 것
- 대부분의 경우 클래스의 정의가 곧 추상화이기도 하지만, 클래스 없이도 추상화를 통한 객체지향 접근이 가능한 경우도 있음(아주 예전의 자바스크립트?)

#### 2) 캡슐화

- 객체 내부의 구현부를 __`외부로부터 은닉`__ 할 수 있는 특성
- 객체 내부의 여러 속성이나 메소드 등을 외부에서 알 수 없도록 하면, 외부에서는 이를 모른 채로 상호작용하는 것
- 따라서 일부 드러난 정보만 가지고 이루어지는 상호작용에 문제만 없으면, 얼마든지 외부에 드러나지 않은 내부 속성들을 외부 변수로부터 독립적으로 관리할 수 있음
- 보통 여러 객체지향 언어에서 라이브러리를 배포하는 과정을 보면 캡슐화가 어떤 식으로 적용되는 지 확인할 수 있을 것 

#### 3) 상속

- 하나의 클래스가 가진 속성이나 메소드를 다른 클래스가 그대로 물려받는 것
- 새로운 클래스를 작성할 때, 기존에 작성된 클래스의 형식을 그대로 사용 가능
- 이는 다시 말해, 기존의 코드를 재활용함으로써 불필요하게 코드를 중복으로 작성하는 것을 방지

#### 4) 다형성

- 어떤 한 요소에 여러 개념을 넣어놓는 것으로, __`하나의 객체가 여러 타입을 가질 수 있는 특성`__ 을 의미함

- 아래와 같이 부모 타입의 참조변수로 다양한 자식 타입을 참조할 수 있음

  ```swift
  import Foundation
  
  //부모 클래스
  class Person{
    func call(){
      print("사람이에용")
    }
  }
  
  //자식 클래스 1
  class Teacher: Person{
    override func call(){
      print ("선생님이에요")
    }
  }
  
  //자식 클래스 2
  class Student: Person{
    override func call(){
      print("학생이에요")
    }
    func call(_ name: String){
      print("학생 이름은 \(name) 입니다.")
    }
  }
  
  //인스턴스 생성
  var teacher: Person = Teacher()
  var student: Person = Student()
  teacher.call() //선생님이에요
  student.call() //학생이에요
  (student as! Student).call("Lee")
  print(teacher is Person) //true
  print(teacher is Teacher) //true
  print(teacher is Student) //false
  
  
  ```

- 부모 클래스로부터 상속받았을 때, 부모 메소드를 재정의하는 방법은 크게 2가지가 있음

  - __`오버라이딩`__ : 부모 클래스의 메소드를 상속받아서 자식 클래스 내부에서 재정의하는 경우(스위프트의 경우 __`override`__ 키워드를 앞에 붙여야 함)

    ```swift
    override func call(){
      print("학생이에요")
    }
    ```

  - __`오버로딩`__ : 동일한 함수 이름을 사용하되, 파라미터 개수나 타입을 달리하여 메소드를 재정의하는 경우

    ```swift
    func call(_ name: String){
      print("학생 이름은 \(name) 입니다.")
    }
    ```

- 타입 변환, 오버라이딩 & 오버로딩이 결국 다형성의 큰 핵심이 되며 함수명을 기반으로 동일한 명령이더라도, 해당 인스턴스에 연결된 타입에 따라 명령의 해석을 달리할 수 있는 것!

#### 5) 동적 바인딩

- 컴파일 시점이 아닌 런타임 시점에서 바인딩이 변경될 수 있는 특성
- 예를 들어 자식 클래스 인스턴스를 하나 생성했는데, 타입 선언을 부모 타입으로 한 경우에 동적 바인딩이 일어날 수 있음
- 인스턴스 내부의 오버라이딩된 메소드를 호출했는데, 코드상으로만 보면 부모 메소드를 호출해야 할 것처럼 보이지만 런타임 시점에 맥락상 오버라이딩된 자식메소드를 호출해야 하는 것으로 판단하는 경우
- 다형성과 연결되어, 좀 더 유연하게 다형성을 적용할 수 있도록 보장해줌

​    

## 2. Porotocol Oriented Programming

> POP가 어떤 식으로 OOP의 한계를 극복하는 지 알아본다.

- 위에서 OOP의 대표적인 특징을 열거했지만, OOP를 특별하게 만들어주는 주요 특징은 결국 __`상속`__ 과 __`다형성`__ 에 있음

  - 상속을 통해 코드를 재사용하고 다양하게 타입을 확장할 수 있고, 다형성을 통해 한 객체가 여러 타입에 접근할 수 있음

- 하지만 상속해야 하는 경우가 많아지거나, 부모 - 자식 - 손자 순으로 상속의 깊이가 깊어지면 오히려 상속 관계가 복잡해지는 문제가 생김

  - 동일한 기능의 구현을 위해 부모 클래스 전체를 불필요하게 상속받기 때문에, 불필요한 속성을 가지고 있어야 함
  - 클래스의 경우 참조 타입이기 때문에, 상속의 깊이를 한 단계씩 파고 들면서 동적 바인딩 및 참조 카운팅을 위한 연산 또한 그만큼 많이 발생

  ```swift
  class Building{
    func call(){
      print("건물")
    }
  }
  
  class Apartment: Building{
    override func call(){
      print("아파트")
    }
  }
  
  class HeraPalace: Apartment{
    override func call(){
      print("주상복합아파트")
    }
  }
  ```

- POP는 결과적으로 위에서 언급한 OOP에서의 상속의 한계를 보완해주는 패러다임이라 할 수 있음

- 우선 불필요하게 전체 클래스를 상속받지 말고, 전체를 각 필요한 단위 별로  __`Protocol`__ 로 쪼개서 필요한 프로토콜만 채택하는 식으로 보완

  ```swift
  class Person{
    func hear(){
      print("듣는다.")
    }
    func tell(){
      print("말한다.")
    }
  }
  
  class Kkondae: Person{
    override func hear(){
      print("듣고 싶은 것만 듣는다.")
    }
    override func tell(){
      print("하고 싶은 말만 뱉는다.")
    }
  }
  ```

  - 위의 예시에서 __`Person`__ 을 상속받아 다양한 자식 클래스를 파생시킬 수 있지만, 내부를 들여다보면 __단순히 말하는 부분만을 상속받고 싶은 경우__ 인데도 불구하고, __말하는 부분과 듣는 부분을 모두 상속받아야 하는 경우__ 가 존재함
  - 여기서 말하는 부분과 듣는 부분을 아래와 같이 프로토콜로 나눠서, 각각 필요한 것만 채택하도록 변경하는 것

  ```swift
  protocol Audible{
    func hear()
  }
  protocol Speakable{
    func tell()
  }
  
  class Kkondae: Audible{
    func hear(){
      print("듣고 싶은 것만 듣는다.")
    }
  }
  ```

  - 원하지 않으면 Speakable 프로토콜은 채택하지 않도록 함으로써 tell()을 구현 안해도 되는 이점이 있음
  - 상속과 달리 결국 프로토콜의 채택은 __`기능의 확장이 수평적으로 발생`__ 한다는 특징이 있음

- Swift의 경우 __`구조체는 상속이 불가능`__ 하다는 특징이 있지만, POP의 채택을 통해 구조체에도 상속의 특징을 적용할 수 있음

  - 굳이 예시를 적진 않았지만, 당연히 구조체도 프로토콜을 채택할 수 있기 때문에 확장하고 싶은 기능이 있으면 이것의 청사진이 포함된 프로토콜을 확장 대상인 구조체에 채택시키는 것!
  - 이 경우에는 굳이 상속의 이점을 얻겠다고 참조타입을 일일히 쓰는 것보다, 원하는 기능만 확장하기 위해 구조체-프로토콜 채택 조합을 사용하여 값타입을 사용함으로써 효율성을 제고할 수 있겠음(뇌피셜)
  - 특히 __`다중 상속`__ 이 적용되야 하는 상황이라면, 여러 참조타입을 상속받는 것보다 여러 프로토콜을 채택시키는 것이 비용적으로 더욱 효율적

- 정리해보면... OOP와 대비되는 POP의 특징을 아래와 같이 요약할 수 있음

  - **프로토콜 채택을 통해 수평적으로 기능을 확장**
  - **구조체에 프로토콜이 채택 가능하기 때문에, 값타입에도 적용 가능**
  - **필요한 여러 프로토콜을 채택시켜 다중 상속처럼 사용할 수도 있음**

