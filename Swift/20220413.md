# Swift Generic

### 제네릭 사용의 일반적인 이점

- 어떠한 타입에도 유연한 대응이 가능하며 제네릭으로 구현한 기능과 타입은 재사용이 쉽고, 코드의 중복을 줄일 수 있다는 장점이 있음

```swift
public struct Array<Element> : RandomAccessCollection, MutableCollection {
  //Swift 배열 구현
}
```

- 위의 코드는 Swift의 배열 타입의 일반적인 구현 형태인데, __`<Element>`__ 와 같이 제네릭을 사용하고 있음
- 제네릭을 사용하지 않을 경우에는 배열에 한정된 타입만 담을 수 있지만, 위와 같이 제네릭을 사용함으로써 원하는 타입을 모두 담을 수 있는 것
- 단, 제네릭 타입에 __`extension`__ 을 적용하고자 하면, 확장부에서는 타입 매개변수를 따로 명시하지 않고 기존 제네릭 타입에 정의되어있는 타입을 가져다 사용 

​    

### Any를 사용하면 안될까?

```swift
//Case 1 : Any 사용
func swapTwoValues(_ a: inout Any, _ b: inout Any) {
  let temp:Any = a
  a = b
  b = temp
}

//Case 2 : 제네릭 사용
func swapTwoValues<T>(_ a: inout T, _ b: inout T) {
  let temp: T = a
  a = b
  b = temp
}
```

- 사실상 제네릭을 사용하면 __다양한 타입을 유연하게 사용할 수 있다는 점__ 이 핵심인데, __`Any`__ 를 사용하는 것과 큰 차이가 없다는 반문을 제기할 수 있을 것
- 위의 코드를 보면 제네릭을 사용한 경우와 Any를 사용한 경우가 큰 차이가 없어 보이지만, __Any의 경우에는 해당 타입 변수에 구체적으로 어떤 타입의 값이 있는지 알기 어려움__
- 또한, 파라미터로 받아야 할 a와 b변수의 타입을 동일한 타입으로 유지하고 싶어도 __Any이기 때문에 두 변수의 타입이 서로 불일치할 수도 있음__
  - 제네릭을 사용한다면 __적어도 두 변수의 타입이 일치할 것이라는 것은 제네릭 함수 코드 명시만 보고도 알 수 있음__

> 스위프트 컴파일러는 보통 문법 검사 시에는 Generic Placeholder로 명시된 타입에 대해서는, 이것의 실제 타입에 대해선 신경쓰지 않음

- 결국 Any를 사용했을 때 위와 같은 한계가 발생하기 때문에 제네릭을 사용해 이를 극복하는 것

​    

### 제네릭 타입 제약과 프로토콜 연관타입

- 일반적인 제네릭의 사용 시에 타입 매개벼수는 타입의 제약 없이 사용 가능하지만, 여기에 __특정 타입에 한정되어 처리할 수 있도록__ __`타입 제약`__ 을 줄 수도 있음
- 대표적으로 Dictionary 타입에서, __`Key`__ 의 경우 제네릭을 적용해서 다양한 타입이 올 수 있지만 __`Key:Hashable`__ 과 같이 Hashable을 채택한 타입으로 한정하고 있음

```swift
public struct Dictionary<Key: Hashable, Value> : Collection, ExpressibleByDictionaryLiteral { }
```

- 단, __타입 제약의 대상은 클래스 타입 혹은 프로토콜 타입만 가능함__
- 프로토콜에도 제네릭을 적용할 수 있지만, 일반적인 방식ㄷ으로 사용하진 않고 프로토콜 내부에 __`associatedtype`__ 키워드를 사용함
  - 연관타입 정의시에 여기에 타입제한을 걸 수도 있음

```swift
protocol SomeProtocol {
  //연관타입 정의(연관타입에 타입제한을 걸 수도 있음, 여기서는 Hashable 채택의 조건 추가)
  associatedtype Item: Hashable
  //연관타입을 파라미터로 받는 함수
  func someFunction(_ item: Item)
}
```

- 위의 Item은 제네릭의 Placeholder과 마찬가지로 아무 의미가 없고, 이후 프로토콜 채택 후 정의 시에 구체적으로 어떤 타입이 될 지 결정됨

```swift
class SomeClass: SomeProtocol {
  func someFunction(_ item: String) {
    print(item)
  }
}
```

- 위의 경우에는 프로토콜 채택 후 함수를 구현하면서 item의 타입을 String으로 지정했는데, 자동으로 연관타입이 String으로 결정된 것
- 제네릭 타입의 경우 타입 자체 외에도 연관된 다른 타입에도 __`where`__ 키워드를 사용하여 제한을 걸 수 있음(Generic Where)
  - 아래의 경우에는 __`A.Item == B.Item`__ 의 조건을 걸어서 SomeProtocol이 아닌 A가 내부에 가지고 있는 타입을 서로 비교한 것

```swift
func someMethod<A: SomeProtocol, B: SomeProcotol>(_ a: A, _ b: B) where A.Item: Hashable  {
  //A가 가지고 있는 원소의 타입이 Hashable을 채택해야 한다는 조건이 추가된 것
}
```