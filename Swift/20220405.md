## 1. Http 프로토콜이란 무엇인가

### Http의 개념

- HyperText Protocol의 약자로, 문서의 전송을 위한 약속된 통신 규칙으로 해석할 수 있음
- 보통 80번 포트를 사용하고 크게 __`서버`__ 와 __`클라이언트`__ 간에 __`요청`__ 과 __`응답`__ 을 주고받는 형태로 구성되있음

### 비연결 지향

- Http는 __`비연결 지향`__ 의 특성을 가지고 있는 데, 이는 클라이언트가 요청을 보낸 후 서버가 응답을 마치면 연결을 바로 끊는 성질을 말함
  - 이렇게 하는 이유는 연결을 과하게 길게 유지함에 따른 서버에의 오버헤드를 줄이고자 함임
  - 하지만 __`연속성`__ 이 필요한 경우에 대해서는, 클라이언트가 이를 위해 매번 새롭게 요청을 보내고 응답을 받는 과정을 거쳐야 하기 때문에 그만큼의 오버헤드를 발생시킨다는 단점이 있음
  - 구체적으로 얘기하면 hand-shaking을 매번 해야 하는 번거로움이 있단 것
- __`Keep-Alive`__ 헤더를 통해 바로 위에서 언급한 오버헤드를 줄일 수 있는데, 이는 해당 헤더를 명시하면 지정된 시간 동안 서버와 클라이언트 간에 패킷 교환이 없으면 서로의 상태를 확인하기 위한 패킷을 주기적으로 보내는 과정이 일어남을 의미함
  - 만일, 상태 확인을 위한 패킷에 아무런 반응이 없으면 연결이 해제되는 것

### 무상태성과 무상태성 극복

- Http의 비연결 지향적인 특성으로 인해, 이전의 정보나 통신상태 등을 저장하지 않는 특성을 말함

  - 서버는 클라이언트의 상태를 저장하지 않으므로, 제대로된 응답만 내려줄 수 있다면 다른 서버에서 요청을 처리해도 상관이 없어진다는 이점이 있음

- 클라이언트가 2번의 요처을 보냈을 때 서버는 기본적으로 이것이 같은 클라이언트로부터 온 것임을 식별할 수 없는 것

- 비연결 지향 특성과 마찬가지로 과도한 서버에의 부하를 줄이기 위한 것이지만, 클라이언트의 특정 상태를 유지할 수 없다는 단점 또한 존재함

- 예를 들어 로그인의 경우에는, 클라이언트가 로그인에 성공해도 로그인 상태를 유지할 수가 없는 문제가 발생하는 것

- __`쿠키`__ : 이름, 값, 0개이상의 속성의 3가지 요소로 구성되며 클라이언트 사이드에 저장되는 정보로, 브라우저에 서버 관련 쿠키 정보가 존재하면 http 요청 시에 기본적으로 헤더에 쿠키를 담아 전송하게 됨

  - 서버는 요청을 받으면 쿠키를 생성하여 클라이언트에게 보내게 되고, 클라이언트는 서버로 부터 받은 쿠키를 다시 자신의 디렉토리에 저장하는 것
  - 이후 쿠키를 동반한 요청이 들어오면 서버는 쿠키를 참고하여 비즈니스 로직을 수행

- __`세션`__ : 쿠키와 달리 서버 사이드에 저장되는 정보이며, 클라이언트 관련 정보일 경우에는 이것이 웹브라우저에 노출되지 않기 때문에 상대적으로 더욱 안전한 형태임

  - 브라우저의 종료 전까지는 세션이 유지되기 때문에 주로 클라이언트의 로그인 상태 유지 등의 상황에 활용할 수 있음
  - 세션을 통해 서버에 클라이언트 정보를 저장할 경우에는, 보통 클라이언트를 구분하기 위한 고유 아이디를 부여하는데 이를 __`세션 아이디`__ 라고 부름
  - 즉, 클라이언트마다 부여된 세션 아이디를 통해 개별 클라이언트를 서로 구분하는 것

- 세션도 기본적으로 쿠키를 기반으로 한 기술이며 __`set-cookie`__ 헤더를 활용함

  1) 클라이언트(브라우저)가 서버에 요청을 보냄

  2) 서버는 요청받은 클라이언트에 대해 세션 아이디를 부여하고 클라이언트를 식별함

  3) 이후 응답 시에  __`set-cookie`__ 헤더의 쿠키에 세션 아이디를 포함시켜 전송함

     ```
     set-cookie : sessionid: a1x2fz
     ```

  4) 클라이언트는 이후의 요청에 대해서는 부여받은 세션 아이디가 담긴 쿠키를 다시 요청 헤더에 넣어 전송

  5) 이후의 요청을 받은 서버는, 받은 요청 메시지의 헤더에 있는 쿠키로부터 세션 아이디 및 세션 관련 정보를 확인한 후 클라이언트를 식별하여 이에 맞는 로직을 처리하게 되는 것

### Http 메시지

- Http는 클라이언트와 서버 간에 Http 메시지를 교환하는데, 여기에는 통신 과정에서 교환된느 정보가 담겨 있음

  - 누가 보내느냐에 따라서 요청 메시지, 응답 메시지로 각각 불림

- Http 메시지는 복수행의 데이터로 구성된 텍스트 문자열의 형태로 __`메시지 헤더`__ 와 __`메시지 바디`__ , 그리고 __`개행 문자`__ 로 구분됨

- __`메시지 헤더`__ : 서버와 클라이언트가 반드시 처리해야 할 요청이느 응답에 대한 내용 및 속성이 정의된 부분으로 메시지 바디의 크기나 인증 정보, 캐시 관리정보 등을 명시 

  - 요청 메시지일 경우에는 헤더의 첫 시작을 요청 라인(Request Line)을 두도록 하며, 여기에는 요청 메소드의 요청 URI, 그리고 Http 버전 정보가 명시됨

    ```
    GET/search Http/1.1
    ```

  - 응답 메시지일 경우에는 헤더의 첫 시작을 상태 라인(Response Line)을 두도록 하며, 여기에는 Http 버전 정보와 상태 코드 및 응답 결과가 명시됨

    ```
    HTTP/1.1 200 OK
    ```

- __`메시지 바디`__ : 서버와 클라이언트 간에 전송되는 데이터 자체가 담긴 부분으로 HTML, json 등 바이트 형식으로 표현 가능한 모든 데이터를 담을 수 있음

- __`개행 문자`__ : 메시지 헤더와 메시지 바디를 구분하기 위한 한 줄의 공백을 의미함

### Http 요청 메소드

- GET : 서버로부터 특정 데이터를 받을 때 사용하며 멱등성을 지님
  - 특정 데이터를 같이 보내고 싶을 경우에는 메시지 바디를 사용하지 않고 URL의 쿼리 파라미터에 데이털르 포함시켜 전달함
- HEAD : GET과 비슷하지만, 응답 메시지에 헤더만 존재하고 바디는 없는 방식임
  - 큰 데이터가 아닌 단순히 리소스의 존재 및 변경 여부 등의 정보만 필요할 때는 굳이 바디에 데이터를 넣을 필요가 없기 때문
  - 하지만 크기가 작아도 중요한 정보라면 서버로 GET요청을 보냈을 때도 응답 헤더가 반드시 동일해야 함 
- POST : 서버가 처리해야 할 데이터를 전송하며, 보통은 새로운 데이터를 서버에 등록해야 할 경우가 이에 해당하고 멱등성을 지니지 않음
  - 처리해야 할 데이터는 요청 메시지 바디에 포함됨
- PUT : 서버에 이미 존재하는 데이터를 수정해야 할 경우에 사용해야 하며 POST와 달리 멱등성을 지님
- PATCH : PUT과 동일하나 일부만을 수정할 경우에 사용되는 요청 방식
- DELETE : 서버에서 특정 정보를 제거하고자 할 때 사용하지만, 서버가 요청을 무시할 수도 있기 때문에 요청을 보냈다고 반드시 삭제가 보장되지 않음

### Http 응답코드

- 100-199 : 정보
- 200-299 : 응답 성공
- 300-399 : 리디렉션 발생할 경우
- 400-499 : 클라이언트 측 에러
- 500-599 : 서버 측 에러

​        

## 2. Http와 Https의 차이

- http 통신은 기본적으로 메시지 바디에 들어가는 데이터가 암호화되지 않기 때문에, 보안에 취약하다는 한계가 있음
- 이를 극복하기 위해 Http에 암호화를 추가하여 보안을 강화한 것이 Https이며 443포트를 사용하고 모든 요청과 응답 데이터가 네트워크 계층을 거치기 전에 암호화됨
- 정확히는 응용계층과 전송계층 사이에 별도의 보안계층을 둠으로써 암호화가 가능하게 한 것

### SSL 계층과 TLS, 암호화 방식

- SSL은 기본적으로 클라이언트와 서버 간에 전송되는 데이터를 암호화하기 위한 표준 보안 기술을 의미하고, TLS는 SSL을 기반으로 하여 보안성을 더욱 향상시킨 기술임
  - SSL 3.0(1) -> TLS 1.0 버전이라고 보는 것이 일반적임
- Https는 기본적으로 Http에 TLS가 추가된 것이라고 보면 됨

- 암호화 방식은 크게 대칭키 암호화 방식과 공개키 암호화 방식이 존재함
- __`대칭키 암호화 방식`__ 은 암호화 및 복호화에 동일한 키(대칭키)가 사용되는 방식으로, 수신자와 송신자가 대칭키를 공유하고, 대칭키가 중간에 탈취될 경우에는 제 3자가 복호화를 할 수 있기 때문에 상대적으로 위험한 방식임
- __`공개키 암호화 방식`__ 은 암호화와 복호화에 서로 다른 키를 사용하도록 함으로써 대칭키 암호화 방식의 한계를 극복한 방식임
  - 만일 A라는 키로 암호화를 했다면 이에 대응되는 B라는 키로 복호화를 해야 하고, 반대로 B로 암호화를 할 경우에는 A로 복호화를 해야 하는 방식임
  - 보통 암호화에 사용되는 키는 공개되기 때문에 __`public key`__ 라고도 부름
  - 복호화에 사용되는 키는 비공개기 때문에 __`secret key`__ 라고 부르며, 이는 호스트만이 알 수 있음
- 공개키 암호화 방식을 적용한 데이터 전송 과정은 크게 아래와 같다고 보면 됨
  - (공개키의) 송신측은 수신측에 자신의 공개 키를 공개함
  - 수신 측은 공개키로 암호화를 해서 데이터를 송신측에 다시 전송함
  - 송신측은 암호화된 데이터를 전달받으면, 자기가 가진 비공개 키로 이를 복화해서 데이터를 읽어들임

​    

## 3. TCP/UDP의 차이

- 전송 계층(__`Transport Layer`__) 에서 어플리케이션 계층(4계층)에서 데이터를 전달받고, 이것의 전송 및 흐름에 있어서의 신뢰성 보장을 확보하기 위한 역할을 수행
- 여기서 신뢰성 보장을 확보하기 위해 사용되는 프로토콜로 __`TCP`__ , __`UDP`__ 가 있는 것
- TCP는 연결지향형으로 전송하는 패킷에 하나의 오류라도 있으면, 이를 재전송해서 에러를 복구하지만 UDP는 전송지향형 프로토콜로 패킷이 중간에 유실되거나 오류가 검출되도 이에 개의치 않고 계속해서 데이터를 전송함
- TCP의 경우 사전에 통신이 정상적으로 이루어질 수 있는 지를 확인하게 위해 __`3-Way Handshaking`__ 과정을 거치는데, 상태확인을 위한 데이터 패킷을 주고 받는 과정임
  - SYN_SENT
  - SYN_RECEIVED
  - ESTABLISHED

​        

## 4.  REST란 무엇인가?

- 웹에 존재하는 자원에 고유한 URI를 부여하여 활용하는 방식을 의미함
- 자원을 정의하기 위해, 자원에 대한 주소를 지정하는 방식을 정하고 고유한 주소를 부여받을 수 있도록 한 것
  -  자원의 위치는 Http URI를 통해 명시하고, 자원의 획득 및 처리 방법(CRUD)는 Http Method를 통해 명시함

- REST의 구성요소는 크게 __`자원`__ 과 __`행위`__ , __`표현`__ 으로 나눠볼 수 있음
  - 자원 : 모든 자원이 가진 고유한 ID로 Students/1과 같은 Http URI를 의미함
  - 행위 : 자원의 조작 방식을 지정하기 위해 Http 메소드를 사용하여 행위를 표현함
  - 표현 : 클라이언트가 요청을 보낼 때, 서버가 응답하는 자원의 상태를 의미하며 JSON, XML 등의 자원 데이터의 형식으로 나타낼 수 있음

​        

## 5. 웹브라우저에 URL을 입력한 후 일어나는 일

> www.daum.net, www.google.com 등을 입력하면 어떤 과정을 거쳐 페이지를 볼 수 있는 걸까

- 브라우저는 우선 사용자가 입력한 URL을 파싱함

  - 흔히 URL의 정확한 구조는 Protocol + URL + Port 로 되어있지만, 사용자는 보통 브라우저에 URL 부문만 쳐도 알아서 Protocol과 Port가 붙는 것을 확인할 수 있음
  - 이는 보통 브라우저에서 기본으로 제공하는 기능이라고 보면 되며, 프로토콜은 기본으로 Http로 접속을 시도하고 만일 Https가 적용된 사이트일 경우에는 300번대 응답 코드를 확인해서 Https로 재접속을 시도하는 것
  - 포트의 경우에는 사용하는 프로토콜에 맞춰 80번이나 443을 알아서 맞춰주는 것

- __`HSTS(Http Strict Transport Security)`__ 목록을 조회하여 URL이 여기에 포함될 경우에는, Https 프로토콜로 바로 요청을 보냄

  - 해당 과정을 거치는 이유는 보통의 경우 Https로 브라우저가 자동으로 리디렉션 되는 경우는 서버 쪽에서 수행하는 것으로,  우선은 최초로 Http로 요청을 보내는 과정을 수반하기 때문에 이 과정에서 평문으로 보낸 데이터가 탈취당할 수 있는 위험을 방지하기 위함임(301, 302 Redirect)

  - 최초로 사이트에 접속을 시도하고자 할 때, (HSTS가 적용된) 웹서버에서 HSTS 설정에 대한 정보를 브라우저에 응답하고, (HSTS를 지원하는) 브라우저는 이를 근거로 일정 시간(__`max-age`__) 동안 HSTS 응답을 받은 사이트에 대해서는 이후부터 강제로 Https로 접속하도록 하는 것

    ```
    Strict-Transport-Security: max-age=155552000; preload
    ```

  - HSTS 응답 헤더를 받은 브라우저에, 해당 웹사이트를 Http로 접속할 경우 __`307 Internal Redirect`__ 응답이 떨어지는 것을 볼 수 있는데, 이는 서버가 아닌 브라우저 자체에서 내부적으로 Https가 적용된 페이지로 리디렉션 했음을 의미하며, 결과적으로 브라우저와 웹서버 간의 Http 통신이 이루어지지 않았기 때문에 상대적으로 더 안전한 것

- 이후 도메인 이름 형태로 입력된 URL은 IP 주소로 변환되야 하는데, 브라우저는 로컬 호스트 파일 혹은 브라우저의 캐시에 해당 URL에 대한 접속 정보가 존재하면 바로 접속을 시도하고, 그렇지 않은 경우라면 __`DNS(Domain Name Server)`__ 에 요청해서 URL을 IP주소로 변환함
  - **`IP 주소`** 는 통신 상대가 되는 호스트들을 식별하기 위한 정보로, **네트워크 상에서 호스트의 주소 정보** 정도로 이해하면 됨
  - DNS 서버는 도메인 이름과 이에 매칭되는 IP주소를 관리하는 서버임
- DNS서버로부터 IP주소를 전달 받으면, 해당 서버로 요청을 보내야 하는데 일단은 목적지만 알고 목적지 까지 도달하는 방법은 모르는 상황이기 때문에 __`라우터`__ 의 __`라우팅 테이블`__ 을 참고하여 목적지 까지의 경로를 지정해줌
- 이후 실질적인 통신을 위해 IP 주소를 물리적인 컴퓨터 주소에 해당하는 MAC 주소로 변환해야 하는데, 이를 위해 __`ARP(Address Resolution Protocol)`__ 이라는 변환 프로토콜을 사용함
- MAC 주소까지 도출되면 실제 요청을 받아야 할 서버에 접근이 가능해진 것이며, 이후부터는 실질적인 통신을 위해 (TCP통신의 경우) TCP 소켓 연결을 진행하는데, 이는 __`3-way-handshaking`__ 과정을 통해 진행됨
  - 만일, Https 요청인 경우에는 암호화를 위한 __`tls handshaking`__ 과정이 추가됨
- 위의 과정들이 모두 완료되면, 서버에게 응답 데이터를 달라고 요청하면 되며, 서버가 요청을 받고 유효하다고 판단되면 적절한 응답을 생성하여 클라이언트(브라우저)에게 전달함
- 브라우저는 서버에서 보낸 응답을 해석하여 사용자에게 적절한 형태로 보여주게 됨
  - HTML, CSS, Javascript의 형태로 오면 이를 토대로 DOM 형태를 구성해서 사용자에게 웹사이트를 보여주는 것

​    

## 6. Swift에서 Http 통신하기

### URLSession

- iOS에서 서버와의 통신을 위해 제공하는 API로, http 통신을 포함하여 인증 및 쿠키 관리, 캐시 관리 등을 지원함

- 기본적으로 Request, Response의 두 가지를 가진 기본적인 구조이며, Request는 URLRequest 객체를 만들어서 헤더 등의 옵션을 설정하거나 URL 객체를 가지고 직접 통신하는 형태가 있음
- Response는 URLSession 객체로 Task를 만든 후, 이것의 completion handler에 해당하는 클로저로 응답을 받아 처리하거나, URLSessionDelegate 프로토콜 채택을 통해 delegate method 구현을 통해 응답을 받아 처리하는 형태가 있음
- URLSession은 크게 3가지 종류의 세션이 존재함
  - Default : 기본적인 세션으로 디스크 기반 캐싱을 지원
  - Ephemeral :  데이터를 따로 저장하지 않는 형태의 세션
  - Background :  앱이 종료된 이후에도 통신이 이루어지는 세션

-----



### 추가학습

- IP 프로토콜 왜 존재하며 어떤 일을 하는 걸까? : 전 세계 컴퓨터의 네트워크상의 고유한 주소를 표현할 수 있는 주소체계

- TCP : 패킷의 순서를 확인하는 매커니즘
- CA가 tls 인증서를 생성하고 검증하는 역할을 수행
- 1.0 -> 1.1 -> 2.0(서버 푸쉬?) ... HTTP 버전별 차이에 대해서 더 학습
- 원래 클라이언트 요청이 없으면 응답을 보낼 수 없는데, 서버 푸쉬를 적용해서 이것이 가능해진 것
- API Gateway : REST API 서버가 한 대가 아니고, 여러 대일 경우에 여러 대의 서버에 와야 할 요청을 한 군대에서 모아서 처리할 때 사용하는 것(게이트웨이)
  - 게이트웨이의 라우팅
  - 로드밸런싱?
- URI와 URL의 차이? URI는 특정 리소스를 나타내는 아이디를 나타내는데, 이것을 주소 형태로 나타낸 것이 URL이고 이름 형태로 나타낸 것이 URN
  - URN은 거의 안쓰이기 때문에 URI와 URL은 거의 동일한 것처럼 여겨짐