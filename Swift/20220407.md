# 프로토콜 조금 더 심화

### 프로토콜은 무엇인가?

- 프로토콜은 특정 역할 수행을 위한 메소드나 프로퍼티 등에 대한 청사진 역할을 수행(자바의 인터페이스와 비슷하다.)
- 프로토콜은 인터페이스와 마찬가지로 어떤 메소드와 프로퍼티를 가지는 지 정의만 하고, 구체적인 내용은 구현하지 않음
  - 구현에 대한 책임은 __프로토콜을 채택한 구체타입에 있음__
- 프로토콜의 요구사항을 모두 따른 타입에 대해서는 __해당 프로토콜을 준수한다__ 라고 표현
- 프로토콜 또한 하나의 타입으로 사용할 수 있기 때문에 타입 사용이 허용되는 곳에 프로토콜을 사용할 수 있음
- 프로토콜 타입은 추상타입이기 때문에 하나의 일관된 인터페이스를 가지고, 여러 구체 타입과의 상호작용이 가능하도록 함



- 프로퍼티에 대한 요구사항을 채택할 때는, 읽기와 쓰기의 허용 여부를 결정해야 함

  ```swift
  protocol SomeProtocol{
    var someProperty: String { get set }
  }
  ```

- 프로퍼티에 대한 요구사항은 항상 __`var`__ 키워드만 사용하여 정의해야 함(__`let`__ 사용 불가)

- 즉, 프로토콜에서 속성을 정의할 때는 변수만 가능하고 상수 정의는 불가능한 것!

- 질문 : get-only한 속성에 대해서는 사실상 상수가 아닐까? 그런데 왜 let을 사용 못하게 하는것?

- 메소드에 대한 요구사항을 정의할 때는, 중괄호를 제외하고 이름과 파라미터 및 리턴타입만 작성하도록 함
- 여기서 파라미터를 명시할 때 기본값을 지정할 수 없으며, 타입 메소드의 요구 시에는 static 키워드를 명시해야 함
- 가변 메소드일 경우에는 mutating 키워드를 명시해주면 됨

- 선택적인 요구사항일 경우에는 __`optional`__  키워드를 앞에 붙여주면 되지만 이 경우에는 프로토콜이 objc 속성이 부여된 프로토콜이어야 함

​    

- 프로토콜은 채택한 타입마다 __`protocol witness table`__ 이라는 것이 만들어지는데, 이 테이블은 해당 타입이 구현된 곳으로 연결됨
  - 일반적인 구체 타입 클래스의 경우에는 method dispatching을 위해 virtual method table에 접근하는 것과 차이
- 만일 추상타입 배열을 선언했다면? 배열의 각 인덱스에 해당하는 공간은 모두 크기가 일정해야 하지만, 구체 타입들의 크기가 상이한데 어떻게 동일한 크기를 유지할 수 있을 지에 대해 반문할 수 있음
- 이럴 경우 사용하는 것이 __`Existential Container`__ 인데, 여기서 Existential은 프로토콜 타입을 의미하며 Existential Container은 결과적으로 프로토콜 타입의 컨테이너가 되는 것임
- 만일 컨테이너의 Value Buffer의 고정된 크기인 3 words 범위를 벗어나는 구체타입의 경우에는, 힙에 메모리를 별도로 할당하고 메모리 주소값을 Value Buffer에 저장하게 됨
- 컨테이너의 경우 4번째 word에 대해서 __`Value witness table`__ 을 가리키고 있는데, 이는 값의 생명주기를 관리하는 역할을 수행하는데, 3 words 범위를 벗어나면 VWT에서 __`allocate`__ 메소드를 실행해서 힙 메모리 공간을 할당하고 메모리 주소값을 Value Buffer에 저장하며 __`copy`__ 를 실행해서 값을 해당 공간에 복사하는 것
- 만일 메모리에서 인스턴스를 제거해야 할 경우에는 __`destruct`__ 실행 후 __`deallocate`__ 의 순서로 실행
- 컨테이너의 마지막 5번째 word는 앞서 언급한 __`protocol witness table`__ 을 가리키는 포인터를 가지게 됨
- 결론적으로 프로토콜 타입별로 PWT, VWT가 생성되고, 프로토콜 타입의 인스턴스를 만들게 될 경우 인스턴스 별로 컨테이너를 가지게 되는데 이 컨테이너가 프로토콜 타입에 맞는 PWT와 VWT를 가리키는 것! 

​    

### 제네릭은 무엇인가?

- 제네릭을 사용하면 그 어떤 타입에도 유연하게 대응할 수 있다는 강력한 이점이 있음

-  __`Static Polymorphism`__ 에 대해 생각해보자

  ```swift
  draw(input: Rectangle) //구체타입, 정적 디스패치, 다형성 불가능
  draw<T: Drawable>(input: T) //정적 디스패치, 다형성 가능
  draw(input: Drawable) //동적 디스패치, 다형성 가능
  ```

​    

----

### 추가 생각

1. 프로토콜은 어떤 역할을 수행할까?
2. 프로토콜을 채택하는 것과 준수하는 것은 각각 어떤 개념적인 차이가 있을까?
3. 프로토콜 채택은 객체 상속과 비교했을 때, 어떤 이점을 가질까?
4. 프로토콜 타입 변수의 인스턴스가 있다고 치자.. 어떻게 구체타입을 확인할 수 있을까?
5. 프로토콜에서 상수 속성을 정의할 수 있을까? 불가능하다면 왜?
6. Swift 프로토콜에서 선택적인 요구사항은 어떻게 명시할 수 있을까?
7. 프로토콜 구현체가, 추상 타입 메소드를 호출할 때 어떻게 메소드의 구현 위치를 찾아갈까?
8. 추상타입 배열이 있다고 치자... 배열은 각 인덱스마다 일정한 공간을 유지해야 하는데 추상타입의 구현체의 크기가 각기 상이할 수 있는 상황에서 어떻게 일정한 공간을 유지할까?
9. Existential Container은 어떻게 추상타입 값의 생명주기를 관리할까?
10. 배열, 딕셔너리 등은 안에 여러 가지 타입을 담을 수 있는데 어떻게 이것이 가능할까?

