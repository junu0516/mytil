## 캐싱?

- 위키에 캐시(Cache)를 검색하면 아래와 같이 캐시에 대해 정의를 내림

   ***[컴퓨터 과학](https://ko.wikipedia.org/wiki/컴퓨터_과학)에서 데이터나 값을 미리 복사해 놓는 임시 장소를 가리킨다.*** 

- 값을 미리 복사하는 이유는, 자주 사용해야 하는 데이터일 경우에 해당 데이터가 위치한 곳까지 매번 드나드는 비용을 줄이기 위해 캐시 메모리에 미리 데이터를 복사해놓음으로서 더 빨리 데이터를 얻고자 하기 위함

- Sidedish 프로젝트를 하면서 메모리 캐싱이라는 키워드를 처음 접했고, __`NSCache`__ 를 사용해서 간단한 메모리 캐싱을 구현했음

  - 이전까지는 필요한 이미지 데이터를 서버로부터 __`URLSession`__ , __`Alamofire`__ 등을 사용하여 일일히 요청을 보내고 응답을 받는 과정을 반복했음
  - 메모리 캐싱을 구현한 이후에는 우선은 __`NSCache`__ 로부터 캐싱된 이미지가 있는 지 확인하고, 없을 경우에는 네트워크 요청을 보내도록 했음

- 메모리 캐싱을 했을 때 개인적으로 체감했던 제일 큰 차이는 __서버에의 잦은 요청 횟수를 줄임으로써 좀 더 빨리 데이터를 불러올 수 있다는 점__ 이었음

  - 충분히 빠르고 안정적인 서버라면 사실 캐싱을 하지 않아도 체감상 차이가 없을 정도로 빨리 이미지 데이터를 불러오긴 함
  - 하지만, 서버의 상태가 항상 안정적일 수는 없기 때문에 서버로부터 이미지 데이터를 빨리 불러올 수 없는 것에도 대비해야 함
  - 처음 요청해서 응답받은 데이터를 key-value로 미리 저장해두면 앱 실행 중에 서버가 일시적으로 다운된 상태라 하더라도 캐싱된 데이터를 가지고 우선 사용자에게 보여줄 수 있음

- 단, __`메모리 캐싱된 데이터를 탐색 -> 없을 경우 서버로에 데이터 요청`__ 의 과정은 아래와 같은 고민거리를 양산했음(고민중)

  ![image-20220505184846536](/Users/junu/Library/Application Support/typora-user-images/image-20220505184846536.png)

  - 파일명 혹은 요청URL을 key로 해서 NSCache에 저장했다고 치자.. 추후 서버에서 응답 데이터를 변경했을 경우 기존에 캐싱된 데이터와 서버에서 변경한 데이터의 상이함을 어떻게 판단할 지?
  - NSCache의 경우 운영체제로부터 캐싱을 위한 일정한 메모리 공간을 제공받는데, 캐싱되야 할 데이터 크기의 총합이 메모리 공간의 크기를 벗어난다면?

- 우선 두 번째 고민에 대해서는 NSCache의 경우 __시스템 메모리를 너무 많이 사용된다고 판단될 경우에는 크기가 작은 순으로 데이터를 삭제하는 매커니즘을 포함__ 하고 있다는 점을 참고해볼 수 있을듯함

  *You typically use `NSCache` objects to temporarily store objects with transient data that are expensive to create. Reusing these objects can provide performance benefits, because their values do not have to be recalculated. **<u>However, the objects are not critical to the application and can be discarded if memory is tight. If discarded, their values will have to be recomputed again when needed.</u>***

  

  - 단, 위의 매커니즘은 __데이터가 제거되는 시기__ 까지는 제어하지 않는데 이를 위해서는 __`NSDiscardableContent`__ 를 채택시켜 필요하지 않은 객체를 메모리에서 제거해야 할 때 Counter 변수의 값이 해제를 의미하는 0값이 되도록 함으로써(__`discardContentIfPossible()`__) , 원하는 시점에 메모리가 해제되도록 할 수도 있음

  ***You implement this protocol when a class’s objects have subcomponents that can be discarded when not being used, thereby giving an application a smaller memory footprint.***

​    

## 웹에서의 캐싱

> 웹에서의 캐싱을 여기서 언급하는 이유?
>
> - 크롬과 같은 브라우저가 서버로부터 응답받는 데이터를 어떻게 캐싱하는 지에 대해 어렴풋이나마 알면 좋지 않을까 생각했음
> - 크롬의 경우 개발자도구를 보면, 각각의 데이터가 디스크 캐시와 메모리 캐시 중 어디서 온 것인지가 상이한 것을 볼 수 있는데 이를 각기 다르게 분류한 기준에 대해 알면 좋은 인사이트가 있지 않을까 생각했음
> - 모바일 개발에서도 서버로부터 이미지나 json 파일 등을 가져올 텐데, 상황에 따라 디스크 캐시와 메모리 캐시를 어떻게 적용할 지 나름의 기준을 정하는 데 참고할 수 있을듯함

<img src="/Users/junu/Library/Application Support/typora-user-images/image-20220505174647647.png" alt="image-20220505174647647" style="zoom:85%;" />

- 웹개발을 하면서도 은근히 캐싱에 대해 알게 모르게 많이 접하고 있었음

  ***(그 때 뭔지도 모르고 쓴 코드가 캐싱 처리였다)***

- 위의 그림을 보면 크롬의 경우 응답받은 데이터를 내부적인 기준에 따라 메모리 캐시와 디스크 캐시를 각각 적용하여, 추후 동일한 데이터를 요청했을 때 캐싱된 데이터를 사용자에게 보여줌을 알 수 있음

- 종종 프론트 개발자가 js, css 등의 파일의 내용을 변경하여 배포했는데, 사용자의 브라우저에 변경된 내용이 반영되지 않는 경우에는 대부분 해당 브라우저에서 이전의 캐싱된 데이터를 보여주는 상황이 대부분이었음

- 이럴 경우에는 __브라우저의 캐싱된 데이터를 삭제하도록 고객사에 안내하거나__ , __배포한 파일명 끝에 버전명 같은 임시적인 꼬리표를 붙여서 캐싱 대상이 되지 않도록__ 하는 방식을 적용했었음

  ![image-20220505191117245](/Users/junu/Library/Application Support/typora-user-images/image-20220505191117245.png)

![image-20220505191210858](/Users/junu/Library/Application Support/typora-user-images/image-20220505191210858.png)

​    

### CDN(Content Distribution Network)

<img src="https://t1.daumcdn.net/cfile/tistory/274641365843FEEF0B" alt="CDN 구조" style="zoom:50%;" />

- 데이터를 Origin Server이 아닌, 클라이언트와 Origin Server 사이에 위치한 여러 CDN 서버로 요청해서 데이터를 응답받는 방식이 있음

  ![image-20220505191519441](/Users/junu/Library/Application Support/typora-user-images/image-20220505191519441.png)

- 위와 같이 bootstrap 라이브러리 같은 상대적으로 크키가 크고 보편적으로 사용되는 소스의 경우에는 Origin Server로부터 데이터를 요청하기 보다는, CDN 서버로부터 소스를 응답받아서 사용하는 경우가 많음

-  이럴 경우에는 Origin Server의 입장에서는 해당 데이터를 프로젝트 폴더 안에 모두 포함시켜야 하는 용량적인 부담을 덜 수 있을 뿐더러 클라이언트의 입장에서도 매번 Origin Server에 요청이 몰려서 네트워크 속도가 지연될 수 있다는 부담을 덜 수 있음

- 단, 이러한 방식은 CDN 서버가 먹통이 되면 데이터를 제대로 불러올 수 없다는 점을 참고해야 함(믿을만한 업체의 CDN을 사용하자)

  

## iOS에서의 캐싱

- 크게 __`메모리 캐싱`__ 과 __`디스크 캐싱`__ 의 두 가지 선택지가 있는 것 같으며 __`NSCache`__ 가 메모리 캐싱에 해당되었음
- __`NSCache`__ 를 사용하면 위에서 언급한대로 데이터를 얻기 위해 매번 네트워크 요청을 할 필요 없이 메모리로부터 빠르게 데이터를 얻을 수 있음
- 단, 앱이 종료되면서 메모리가 운영체제에 반납될 경우에는 __`NSCache`__ 에 있던 데이터도 같이 사라지기 때문에 엄밀히 말해서 순수하게 영구적인 데이터를 보관한다고 볼 순 없음
- __`디스크 캐싱`__ 을 사용하면 파일 형태로 하드웨어의 디스크에 데이터를 저장하게 되는데, 이를 통해 __`NSCache`__ 가 가지고 있던 단점을 해결할 수 있는 것
  - 캐싱된 데이터를 찾기 위해서는 보통 __`FileManager`__ 과 같은 입출력 라이브러리를 사용
- 다만.. __`디스크 캐싱`__ 의 잦은 사용은, 그만큼 하드웨어에 저장되야 하는 파일의 수가 많아짐을 뜻하기 때문에 앱 하나가 차지하는 용량이 커질 뿐더러, 캐싱된 데이터를 읽어들이기 위한 __잦은 파일 입출력으로 인해 속도가 메모리 캐싱과 비교했을 때 느리다는 단점이 있음__

- 결론적으로 데이터를 불러오는 속도만 본다면 네트워크 요청, 디스크 캐싱, 메모리 캐싱 순으로 속도가 느리기 때문에 데이터 요청의 흐름 또한 이에 맞춰 역순으로 살펴보도록 하면 될 것 같다고 생각했음
  - 단, 디스크 캐싱이 적용된 데이터가 앱 종료 후에도 사라지지 않는 경우를 생각하고 용량을 어떻게 관리할 지에 대해서도 고민해야 함
  - 또한, 서버에서 배포하는 데이터의 내용이 수정된 경우에는 캐싱된 데이터와 수정된 데이터 간의 상이함을 어떻게 판단할 지에 대해서도 고민해야 함