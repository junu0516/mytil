2022-04-22

# Anti Singleton Pattern in OOP

​    

## Singleton Pattern을 만든 상황

- JSONEncoder, JSONDecoder을 사용하여 json 형식의 데이터를 다루는 클래스를 아래와 같이 만들었다.

```swift
final class JSONHandler{
    
    private static let encoder = JSONEncoder()
    private static let decoder = JSONDecoder()
    
    static func convertJSONToObject<T: Decodable>(from data: Data, to targetType: T.Type)-> T?{
        return try? decoder.decode(T.self, from: data)
    }
    
    static func convertObjectToJSON<T: Encodable>(from object: T)-> Any?{
        return try? encoder.encode(object)
    }
}

```

- __`static func`__ 을 사용하는 싱글톤 객체로 구성했는데, 이렇게 한 이유는 __여러 계층에서 공통으로 사용하는 객체가 될 것이기 때문에 하나를 공유하는 것이 효율적일 것__ 이라고 판단했기 때문이다.
  - 싱글톤 패턴을 사용하는 다양한 이유가 있겠지만, 우선 모든 계층에서 동일한 형태를 사용할 경우에는 굳이 각 계층에서 동일한 인스턴스를 일일히 만들어도 되지 않을 것이라 생각했다.
  - 다시 말하면, 공통으로 사용하는 객체를 하나만 둠으로써 메모리 낭비를 줄일 수 있는 것이다.
- 하지만 이에 대해 아래와 같은 리뷰를 받았다.

​	>>  *swift ios에 대한 anti singleton pattern에 대해서 알아보시는걸 추천드립니다!!*

​    

## Singleton Pattern을 지양하는 이유?

- __`anti singleton pattern`__ 에 대해 검색했는데, 객체지향프로그래밍에서 싱글톤 패턴을 지양해야 한다는 것을 의미하는 것이었다.
- 싱글톤 패턴을 지양해야 하는 이유로 우선 아래와 같이 정리해볼 수 있었다.

### 1) 결합도가 너무 높아진다.

<img src="https://velog.velcdn.com/images%2Fsms8377%2Fpost%2F2df973cf-be73-4bd0-9033-430bf6f630dd%2Fimage.png" alt="img" style="zoom:33%;" />

- 우선 전역 범위에서 단 하나의 객체만을 사용하기 때문에, 싱글톤 객체와 이를 사용하는 다른 객체들 간의 결합도가 높을 수 밖에 없다.
- 결합도가 높다는 것은 그만큼 싱글톤 객체의 리팩토링을 수행할 때, 이에 영향 받는 객체가 많아진다는 것을 의미한다.
- 최악의 경우에는 **싱글톤 객체의 리팩토링에 대한 영향 범위가 어플리케이션 전체**가 될 수도 있다.
- 또한 __싱글톤 객체가 상태를 지닌 경우에는, 여러 객체가 싱글톤 객체에 마음대로 접근하는 상황이 매우 위험할 수 있다.__

​    

### 2) 객체지향의 특성과 맞지 않는다.

- OOP의 주요 특징인 __`SOLID`__ 원칙의 내용과 전역 상태를 가지는 싱글톤 패턴은 우선 서로 맞지 않는다.

- 우선 __`static`__ 속성 및 메소드로 인해 __`상속과 다형성`__ 이라는 OOP의 특징을 적용할 수가 없다.

- 또한 1) 에서 언급한 것과 더불어, __추상타입 의존을 통한 결합도 낮추기__ 가 싱글톤 패턴에서는 어려워진다.

  ```swift
  protocol SomeProtocol{
    func someMethod()
  }
  
  struct SomeObject: SomeProtocol{
    func someMethod(){
      print("Hello")
    }
  }
  
  let object: SomeProtocol = SomeObject()
  object.someMethod()
  ```

  - 위의 코드에서 object 변수의 타입은 추상타입이고 인스턴스는 해당 프로토콜의 구현체가 된다.
  - 이런 식으로 구체타입이 아닌 추상타입에 의존하게 되면, 프로토콜의 구현체의 내용을 수정해도 __추상타입을 의존하는 부분은 수정할 필요가 없어진다__
  - 다시 말해 __결합도가 낮아졌기 때문에 리팩토링으로 인한 영향 범위를 줄일 수 있는 것이다.__
  - 하지만 싱글톤 객체를 사용할 경우에는, 우선 싱글톤 객체의 인터페이스를 미리 정의하기도 힘들 뿐더러 다형성을 적용하기도 힘들기 때문에 위와 같은 상황을 기본적으로 적용하기 어려워진다.

​        

### 3) 테스트가 어렵다.

- 다양한 이유로 싱글톤 패턴은 테스트하기 좋은 구조가 아니라고 하지만, 우선 제일 와닿았던 부분은 __Mock 객체를 만들 수 없기 때문에__ 테스트하기 힘들다고 한 부분이었다.
- 이전에 NetworkHandler이라는 싱글톤 객체를 만들고, static func 안에 __`URLSession`__ 을 사용한 코드를 넣은 적이 있었다.
  - 쉽게 말해 정적 메소드 안에서 요청-응답 처리를 하는 것이다.
- 해당 NetworkHandler의 동작을 단위테스트한다고 하면 보통 아래와 같은 상황을 가정할 것이다.
  - 단지 '테스트'를 위해, 실제 서버에 요청을 보내고 응답을 받는 과정을 단위 테스트 수행 시에 동일하게 하는 것은 비효율적일 수 있다.
  - 따라서 어떠한 '정해진 요청'을 보낸 후, '원하는 응답'을 받는 과정일 미리 가정한 후, 이런 식의 정해진 응답이 온 후의 과정에 대한 기댓값을 테스트하는 것이 효율적이다.
    - 좀 더 나아가 '원하는 응답'이 온 후의 상황과, '원하지 않는 응답'이 온 후의 상황을 각기 가정하여 이후의 처리를 테스트하면 될 것이다.
  - 위와 같이 '정해진 상황'을 가정하여 요청-응답의 흐름을 처리하되, 실제로 서버와의 네트워크 통신을 위한 자원을 사용하지 않는 __`Mock`__ 객체를 따로 만든 후, 단위 테스트 메소드에서 이를 주입받아 사용한다.
- 1), 2) 에서 싱글톤 패턴은 다형성을 적용하기 힘들고, 추상타입 의존을 통한 결합도 줄이기 등이 모두 힘들다고 했는데 이러한 이유로 추상타입의 또다른 구현체가 될  __`Mock`__ 객체를 만드는 것이 힘들다고 볼 수 있다.

