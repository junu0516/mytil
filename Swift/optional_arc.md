# ARC, Optional

> 2022.03.29

## 1. Optional

### Optional이란 무엇이고 왜 필요한가

- Swift에서 미리 타입캐스팅이나 nil 값 체크 등을 위해 사용되는 것으로 __`값이 있을 수도, 없을 수도 있음`__ 을 타나내는 표현임
  - 좀 더 직관적으로 얘기하면 특정 변수에 할당된 값이 nil일 수도 있는 것
- 스위프트에서는 보통 옵셔널 변수 혹은 상수가 아니면 nil을 할당할 수 없으며(컴파일 에러 발생), 만일 상황에 따라 값이 nil일 수도 있는 변수라면 변수 뒤에 __`?`__ 를 붙여 해당 변수를 옵셔널 타입으로 선언함
  - 만일 http 응답을 받는 상황에서, 응답값이 예상치 못하게 nil인 경우가 있을 수 있음
  - 이런 경우에는 응답값을 예측할 수 없는 상황이므로 nil인 경우를 검증해야 하기 때문에, 우선은 nil의 가능성을 내포한 타입으로 받아야 하는 것
- 만일 Optional(String)의 경우는 String값이 옵셔널로 대표되는 일종의 '박스' 안에 감싸져 있는 형태를 생각하면 됨
- 이런 식으로 감싸는 것을 __`래핑(Wrapping)`__ 한다고 표현
- 이후 nil이 아닌 경우 옵셔널 값을 추출하고 싶으면 __`!`__ 를 붙여서 꺼내면 되는데, 이를 가리켜 옵셔널 값을 __`언래핑(Unwrapping)`__ 한다고 표현함
  - 다만, __`!`__ 의 사용은 아무런 검증 없이 강제로 옵셔널 언래핑을 시도하는 것이기 때문에 보통 iOS 개발에서 권장하진 않음
  - 만일 강제 언래핑을 해서 값을 추출했는데, nil인 경우에는 런타임 에러가 발생해서 어플리케이션이 종료될 수 있기 때문

### 옵셔널 체이닝과 옵셔널 바인딩은 무엇인가

- __여러 옵셔널이 마치 자전거 체인처럼 꼬리에 꼬리를 무는 형태로 반복 사용된 형태__ 를 가리켜 __`옵셔널 체이닝`__ 이라고 함
- 체인 구조를 따라가다가 만일 중간에 하나라도 nil인 경우가 발생하면, 옵셔널 체이닝의 최종 리턴값으로 nil을 반환함

- 최종적으로 nil을 리턴할 수 있다는 것은 다시 말해, 값을 추출했더니 nil이 나와서 런타임 오류가 발생할 수 있음을 의미함
- 이런 오류를 방지하기 위해 __`옵셔널 바인딩`__ 을 적용해볼 수 있음
- 옵셔널 체이닝을 적용하도라도 언제든 nil을 리턴할 수 있기 때문에 항상 nil 여부를 확인한 후 값을 추출해야 함
  - 이런 경우에는 다른 언어에서의 null값을 체크하는 것과 굳이 차이가 없어지는 상황이 됨
  - 다시 말해 옵셔널을 굳이? 사용할 이유가 없는 것
  - 또한 옵셔널 체이닝이 적용된 상황이라면, 하나 하나 일일히 값이 있는 지 여부를 확인해야 하기 때문에 콜백지옥과 비슷하게 중괄호가 여러 번 중첩되는 상황이 발생함
- 스위프트는 여기서 차별점을 두고자 옵셔널 바인딩 기능을 제공하는데, 다른 언어처럼 옵셔널 안에 값이 있는 지 확인한 후, 값이 존재하면 __`추출된 값을 변수에 할당시켜서 일정 블록 범위에서 유효하도록 해주는 것`__
  - __`!`__ 를 사용하지 않기 때문에 상대적으로 안전하게 값을 추출할 수 있다는 장점이 있음
- __`if-let`__ 을 사용하면 값이 존재하면, 이를 변수에 담아서 if 블록범위 안에서 바로 사용할 수 있게 하고 __`guard-let-else`__ 을 사용하면 값이 존재하지 않는 경우에 __`빠른 종료(early exit)`__ 으로 처리하도록 함
  - __`guard-let`__ 의 경우에는 값이 존재할 경우에는  else 블록범위 바깥에서 추출한 값을 바로 사용할 수 있음

### 옵셔널은 어떻게 구현되어 있을까?

```swift
@frozen public enum Optional<Wrapped> : ExpressibleByNilLiteral {
  case none
  case some(Wrapped)
}
```

- 옵셔널은 열거형으로 구현되있으며, 제네릭을 사용하기 때문에 원하는 타입을 뭐든 받을 수 있음(열거형과 제네릭의 조합)
  - __`@frozen`__ : 해당 어노테이션이 선언되면 추후 Optional 열거형에 케이스를 추가할 수 없음
  - 추가적인 케이스가 없어질 것임을 미리 컴파일러에 알려주는 역할을 함으로써, default 선언이 필요없어지고 그만큼 컴파일 시간 또한 줄어드는 이점이 있음
  - 보통 라이브러리를 만들 때 이러한 어노테이션을 많이 선언함
- 옵셔널 열거형은 __`ExpressibleByNilLiteral`__ 프로토콜을 채택하고 있는데, 이는 옵셔널 타입에서만 채택하고 있는 것이며 이는 일반적인 경우에 허용되지 않는 nil 값을 해당 타입에 한해서는 사용하겠다는 선언임
- case는 none, some의 두 가지가 존재하며, 각각 값이 없는 경우와 있는 경우를 나타냄
- 따라서 __`==`__ 으로도 nil 여부를 확인 가능하며, 우항에 nil을 그대로 넣거나 .none을 넣어서 사용하면 됨
- some은 제네릭에 선언된 타입에 해당하는 값을 두고 있음(옵셔널 열거형의 __`associated value`__)

​    

## 2. ARC

### ARC란 무엇인가

- Swift에서 자동으로 메모리를 관리해주는 방식으로 Automatic Reference Counting의 의미에서 알 수 있듯 자동 참조 카운팅이 핵심
- 더 이상 필요하지 않은 인스턴스를 메모리에서 해제하는 방식으로 동작함
- 일반적인 __`Garbage Collecting`__ 과의 차이는, __`참조를 계산하는 시점`__ 이 다르다는 점에 있음
- 일반적인 GC는 런타임 시점에 참조 카운팅을 하지만, ARC는 가능하면 __`컴파일 시점에 카운팅을 함`__
  - 이 경우 컴파일 시점에 인스턴스의 메모리 해제 시점을 미리 알기 때문에, 런타임 시점에 메모리 관리를 위한 별도의 자원과 연산이 불필요함
  - 단 그만큼 컴파일 시점에 어떤 방식으로 참조 카운팅을 하는 지 규칙을 알아야 함
  - 단, 여기서 참조 카운팅의 대상이 되는 참조는 __`strong reference`__ 에만 해당됨(__`weak`__ 선언은 참조카운팅에 포함되지 않음)
- 보통 클래스의 인스턴스를 생성할 때마다 ARC는 생성된 인스턴스에 대한 정보를 저장하기 위한 메모리 공간을 별도로 할당하는데, 여기에는 타입 정보 및 저장된 프로퍼티 값 등이 있음
- 이후 인스턴스가 더 이상 사용되지 않는 시점에 ARC가 메모리에서 위에서 언급된 메모리 공간을 할당 해제
  - 해제하기 직전에 소멸자가 정의되있다면, 이를 호출하게 됨
- 좀 더 자세히 얘기하면 보통 ARC의 메커니즘은 *Swift Runtime* 이라는 library에 구현되어있는데, *Swift Runtime*은 동적 할당되는 모든 객체를 [HeapObject](https://github.com/apple/swift/blob/4fd0671e542299d7805e41cf9426640ab3b399af/stdlib/public/SwiftShims/HeapObject.h) 라는 struct로 표현하며 이는 HeapObject에서는 Swift에서 객체를 구성하는 모든 데이터, 즉 reference count와 type meta data를 포함하고 있음
- 참조카운팅 값은 이러한 HeapObject에서 접근
- 컴파일 시점에 컴파일러가 코드를 분석하면서 참조 카운팅을 한 후 적절한 위치에 메모리 할당 및 해제 명령 관련 코드를 삽입하며, 이러한 코드가 런타입 시점에 실행되는 것
- 따라서 ARC의 참조 카운팅은 컴파일 시점에 실행되는 기능이지만, 동적으로 할당되는 메모리들의 참조 카운팅이 위의 이유로 컴파일 시점에 가능한 것!

​        

### Retain과 Retain cycle이란 무엇인가

- __`Retain`__ 의 개념은...(이해한 맥락에 의하면) 힙 메모리 영역을 차지하는 레퍼런스 기반의 인스턴스가 생성될 때 해당 인스턴스를 적어도 하나의 변수가 참조하고 있는 경우를 말하는 것임

  - 예를 들어 특정 변수에 힙 메모리에 할당되는 인스턴스를 만들어주면 retain이 발생하는 것
  - __`retain count`__ 라고 하면, 계속해서 언급하는 참조 카운팅(__`reference counting`__) 이 되는 것

- 일반적인 방식으로 인스턴스를 생성하면 보통은 변수와 강한 참조 방식으로 연결되지만, 이러한 강한 참조는 인스턴스가 다른 인스턴스와 연결할 때 문제를 발생시킬 수 있음

  ```swift
  class SomeClass{
    var some: SomeClass?
  }
  
  var a = SomeClass() //참조카운팅 1
  var b = SomeClass() //참조카운팅 1
  a.some = b //참조카운팅 1 증가
  b.some = a //참조카운팅 1 증가
  
  a = nil //인스턴스 메모리에서 해제(참조카운팅 1 감소)
  b = nil //인스턴스 메모리에서 해제(참조카운팅 1 감소)
  ```

- 위와 같이 a의 인스턴스와 b의 인스턴스가 내부에서 서로를 참조하는, 이른바 __`순환참조`__ 가 일어나면 문제가 생김

- 우선 위와 같은 상황에서 a,b에 할당된 각 인스턴스의 참조카운팅은 외부 선언에서 1회, 내부 속성에 할당할 때 1회로 총 2가 될 것

- 만일 변수 a,b 할당되있던 SomeClass 타입 인스턴스가 메모리에서 해제되면(__`a = nil, b = nil`__ 이 되는 경우) 이를 참조하는 참조카운팅 값이 1 줄어들어서 인스턴스의 참조카운팅은 최종적으로 1이 됨

- 따라서 클래스 내부의 속성인 변수 some이 인스턴스를 참조하고 있어 참조카운팅이 0이 아니기 때문에 ARC는 이를 메모리에서 해제하지 않을 것이지만, 문제는 해당 속성을 감싸던 변수 a,b 자체가 없기 때문에 결과적으로 some이 여전히 참조하는 객체는 __메모리상에는 남아있는 데 쓰임이 없는 상태__ 에 전락해버림

- 이러한 경우를 __`메모리 누수(Memory Leak)`__ 라고 하며, 쓸모 없는 데이터가 메모리를 계속 차지하는 것은 당연히 문제가 됨!

- 이러한 경우를 가리켜 __`Retain Cycle`__ 이라고 부름

​    

### Strong, Weak 참조 방식에 대해 설명하라(Retain Count 방식에 대해 설명하라)

- 위에서 언급했듯이 메모리가 해제되지 않고 좀비 상태로 유지되어 누수가 생기는 현상을 __`Retain Cycle`__ 이라고 부름
- 다시 정리하면, 두 개의 변수에 각각 인스턴스를 할당하고, 해당 인스턴스 내부에서 다시 각각의 인스턴스를 참조하게 하고 인스턴스를 해제했을 때 참조카운팅이 0이 되지 않아서 메모리에 쓰임이 없는 상태로 계속 남아있어 발생하게 되는 것임
- 간단한 말로 이를 __`강한 순환 참조로 인한 메모리 누수`__ 라고 표현해볼 수 있을 것
- Swift에서는 이러한 메모리 누수를 방지하기 위해 참조 상태를 __`strong`__ 외에도 __`weak, unowned`__ 의 두 가지를 더 정의해서 개발자가 상황에 따라서 인스턴스 참조를 강하게 할 지, 약하게 할 지 결정하도록 하고 있음
- __`약한 참조`__ : 자신이 참조하는 인스턴스의 참조 카운팅을 증가시키지 않는 방식으로, 이는 참조하는 인스턴스는 메모리에서 해제될 가능성을 내포한다는 것을 컴파일러에게 알려줌
  - 이러한 참조는 상수에서는 당연히 쓰일 수 없음
  - 약한참조가 가능하려면, 인스턴스가 메모리에서 언제든 해제되서 nil이 될 수 있는 가능성이 있다는 전제가 만족되야 하는데 상수의 경우는 이것이 불가능한 것
  - 따라서 약한 참조는 보통의 경우 nil의 가능성을 내포한 옵셔널로 선언되야 함
- __`미소유 참조`__ : 약한 참조와 마찬가지로 참조 카운팅을 증가시키지 않고 참조하는 방식이지만, 약한 참조와 다르게 nil이 될 가능성이 없다는 전제를 내포하고 있는 방식임
  - 따라서 인스턴스가 메모리에서 해제되더라도 미소유 참조된 경우라면 자동으로 nil이 할당되지 않는 것
  - 따라서 nil의 가능성이 없기 때문에 미소유 참조의 경우에는 옵셔널로 선언되지 않아도 됨
  - 다만, 실제로 메모리에서 인스턴스가 해제된 경우에 이에 접근하려 든다면 nil에 접근하는 꼴이 될 것이기 때문에 런타임 오류가 발생할 수 있음
- 클래스를 참조하는 옵셔널을 미소유 참조로 선언하면  __`미소유 옵셔널 참조`__ 가 되는데, 이는 결국 약한 참조와 같은 상황에 사용하는 경우지만 옵셔널이 항상 존재하는 객체를 가리키거나 그렇지 않으면 nil을 할당해주도록 신경 써야 함
  - 옵셔널 값인 클래스 인스턴스를 강한 참조로 관리하지 않기 때문에, 클래스 인스턴스가 메모리에서 해제될 때 ARC에 의해 관리되지 못하기 때문
  - 결국 미소유참조와 달리 nil이 될 수 있다는 점에서 차이를 보임

```swift
unowned var name: String?
name = nil
```

>  옵셔널은 열거형이기 때문에 값타입인데 ... 어떻게 값타입이 참조 관리 대상이 될까?

- 옵셔널의 경우에는 값 타입이지만 예외적으로 미소유 참조 방식으로 참조 관리가 가능함
- 클래스를 감싸는 옵셔널의 경우에는 참조 카운팅을 하지 않으므로 강한 참조로 관리할 필요도 없음

​    

### 순환참조에 대해 설명하라(강한 순환 참조는 어떤 경우에 발생하는가)

- 강한 순환 참조의 의미는 위에서 설명했기 때문에 패스
- 강한 순환 참조의 경우 인스턴스 간의 참조 외에도, 클로저가 인스턴스의 프로퍼티이거나 클로저가 값 획득(Capturing Values)을 해야 하는 경우에도 발생할 수 있음
- 특정 클래스가 가진 클로저 내부에서 클래스 인스턴스의 속성(해당 클로저 외부)에 접근하려 하거나, 클로저 내부에서 인스턴스가 가진 메소드를 호출하는 경우에도 강한 순환 참조로 인한 문제가 발생할 수 있음

```swift
class SomeClass{
  var name: String = "name"
  var call: ()->Void = {
    print("calling \(self.name)")
  }
}

var a = SomeClass()
a = nil
```

- 이는 클로저 또한 참조타입이기 때문이며, 클로저를 어떤 참조타입 인스턴스 내부의 속성으로 할당하게 되면 해당 클로저의 참조 카운팅도 증가함
- 다시 말해, 하나의 참조타입(클래스 인스턴스)과 다른 참조 타입(클로저)이 서로를 참조하는 상황인 것
- 위의 예시와 같이 우선 클로저 타입 속성이 클래스 내부에 선언되있고, 해당 클로저 내부에서 클래스의 속성을 __`self.`__ 으로 참조하고 있는 상황이 이에 해당됨
- 이런 상황에서 위의 예시에 나온 __`a = nil`__ 이 선언되더라도 클로저가 여전히 __`self`__ 참조를 하기 때문에 소멸자는 호출되지 않음

> 다만, 클로저 내부에서 self를 사용할 경우 이를 여러 번 사용해도 self에 해당하는 인스턴스 참조 카운팅은 1만 증가함

- 이러한 문제는 __`획득 목록(Capture List)`__ 의 사용을 통해 해결할 수 있는데, 쉽게 말해 클로저 내부에서 참조 타입을 획득(캡쳐)하는 규칙을 제시해주는 기능을 의미함
- 클로저 내부에서 참조할 대상을 대괄호로 둘러싼 배열 형태로 작성하며, 획득 목록에 명시된 요소가 값타입인 아닐 경우에는 클로저가 생성될 때 초기화됨

```swift
var a = 0
var b = 0
let closure = {[a] in
	print(a,b)
  b = 20
}

a = 10 //a에 10 할당
b = 10 //b에 10 할당
closure() //0 10이 출력됨
print(b) //20이 출력됨
```

- 위의 예시에서 변수 a의 경우 클로저의 획득 목록에 포함되기 때문에, 클로저가 생성되는 시점에 이미 값 0을 획득하지만 b의 경우에는 아직 값을 획득한 상태가 아님
- 이후 a,b를 변경한 후 클로저를 호출하면 a만 맨 처음 획득한 값을 그대로 사용하는 것을 확인할 수 있음
- 쉽게 말해 획득 목록을 통해 외부 변수의 값을 획득해서 내부에서 사용하는 순간, 내부에서 사용되는 변수는 외부와는 별개의 것이 되는 것

- 만일 획득목록에 참조타입이 포함되있다면 상황은 달라지지만, 이 경우에 대괄호 안에 획득할 참조타입을 명시할 때 __약한 참조 혹은 미소유 참조로 할 것인 지를 선택__ 할 수 있음
- 따라서 캡쳐 대상을 약한 참조로 지정함으로써 메모리의 누수를 방지할 수 있을 것임

​    

## 3. 나올 수 있는 질문들?

> ARC 관련

- arc의 개념은 무엇인가(그냥 개념 정도만)
- arc가 기존의 objective-c의 gc와 다른 차이는 무엇인가
- arc의 참조카운팅이 컴파일 시점의 기능이라면, 동적으로 할당되는 인스턴스 참조 횟수를 어떻게 컴파일 시점에 관리 가능한 지?
- Retain Cycle의 개념 혹은 메모리 누수가 어떤 상황에서 보통 발생하는가?
- 강한 참조와 약한 참조의 차이는 무엇인가
- 강한 참조로 인한 메모리 누수는 어떻게 해결할 수 있을까?
- 약한 참조와 미소유 참조는 어떤 점이 서로 다른가
- 미소유 옵셔널 참조는 무엇인가
- 클로저의 경우에는 ARC의 관리대상이라고 할 수 있을까?
- 클로저를 상황하는 상황에서도 강한 참조로 인한 순환참조 문제가 발생하는데, 보통 어떤 상황이 있을까?
- 클로저 내부에서의 값 캡쳐로 인한 순환참조 문제가 발생할 경우 이를 어떻게 해결할 수 있을까?
- 클로저 내부에서 self로 값을 캡쳐할 때는 어떤 식으로 참조 카운팅이 발생할까
- 값 획득 목록에 값타입과 참조 타입을 선언하는 것은 어떤 차이가 있을까

​        

> Optional 관련

- 옵셔널이란 무엇인가
- 옵셔널은 왜 사용하는가
- 옵셔널 체이닝과 옵셔널 바인딩은 무엇인가
- 옵셔널은 어떤 식으로 구현되어 있는가
- 스위프트는 nil을 직접 사용하는 것을 금지하고 있는데, 옵셔널에서는 어떻게 nil값을 사용 가능한것인지?