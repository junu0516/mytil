# 가상메모리

### 메모리(Memory)?

- 메모리는 프로그램과 프로그램 실행에 필요한 데이터 및 코드를 저장하는 장치를 의미함(하드웨어적 측면)
- 메모리는 컴퓨터 구조에서 크게 내부 기억장치에 해당하는 __`주기억장치(Main Memory)`__ 와 외부 기억장치에 해당하는 __`보조기억장치`__ 로 나눠볼 수 있음
  - RAM, CPU 내부의 레지스터(Register)와 캐시(Cache)가 주기억장치에 해당됨
  - SSD, HDD 등은 보조기억장치에 해당됨
  - 보통 CPU에 가까울 수록 접근 속도가 빠르지만, 그만큼 비용이 비싸고 용량이 적다는 특징이 있음

​    

### 가상메모리(Virtual Memory)?

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/6/6e/Virtual_memory.svg/220px-Virtual_memory.svg.png)

- 컴퓨터 시스템의 메모리 크기보다 더 큰 크기를 가지는 프로세스를 실행하기 위해 사용하는 방법
  - 일반적으로 여러 프로세스는 CPU와 메인 메모리 자원을 공유하는데, 보통 CPU의 경우에는 자원 할당 순서를 기다리는 과정에서 느려지는 상황을 고려하지 이외의 심각한 오류를 고려하진 않음
  - 하지만 메모리 자원의 경우에는 여러 프로세스로부터 지나치게 많은 요구가 있을 경우 프로그램의 논리와 무관하게 공간적인 여유가 없는 것으로 인해 오류가 발생할 수 있음
  - 따라서 가상메모리를 통해 실제로 이용 가능한 메모리를 논리적으로 추상화하여 사용자에게는 마치 실제 메모리처럼 보이게 하고 실제로는 모든 메모리 영역을 할당하지는 않는 것
  - 단순하게 생각하면 __가상 메모리는 메모리가 실제 메모리 공간보다 많아 보이게 함으로써, 프로세스가 실행될 때 프로세스 전체가 메모리에 올라가는 것이 아닌 당장 필요한 부분만 메모리에 올리는 것__ 으로 이해하면 됨

- __`오버레이 기법`__ : 가상메모리 사용 이전에 메모리 부족 문제를 해결하기 위해 사용했던 기법으로, __사용자가 프로그램의 일부분만 메모리에 올려 실행하도록 지정할 수 있게 하는 것__
  - 오버레이 기법이 적용된 프로그램은 메모리를 실제로 덜 사용하는 이점이 있었지만, 이 역시 근본적으로는 프로그램의 일부분만 올리더라도 이를 위한 충분한 메모리 공간을 갖추지 않을 경우에는 비슷하게 메모리 부족으로 인한 오류가 발생한다는 한계가 있었음
  - 가상메모리는 여기서 한단계 더 나아간 것으로 프로그램 실행을 위해 단순히 얼마나 많은 공간이 필요한 가에 집중하지 않고, __프로그램 실행을 위해 최소한 얼마만큼의 공간이 필요한가에 집중한 것__

- 가상메모리 기법은 __프로그램을 실행할 때, 당장 필요한 부분만 메인 메모리에 올리고 필요하지 않은 나머지 부분은 보조 기억장치에 올려두는 방식__
  - 이는 다시 말해 접근 속도가 빠른 RAM과, 상대적으로 속도가 느린 보조 기억장치를 하나로 묶어 마치 하나의 단일한 기억장치처럼 동작하도록 보이게 하는 것
  - 논리적으로는 하나이지만, 실제로는 두 개 이상의 기억장치가 관여하기 때문에 가상(virtual)이란 단어를 사용하는 것!

- 프로그램에는 메모리의 __`실주소(Physical Address)`__ 가 아닌, __`가상주소(Virtual Address)`__ 가 부여되며 실행중인 프로세스가 참조하는 가상주소의 범위는 프로세스의 __`가상주소 공간(Virtual Address Space)`__ 라고 부르고, 사용 가능한 실주소의 범위는 __`실주소 공간(Real Address Space)`__ 이라고 부름
- 언급한대로 프로세스는 오직 가상주소만을 참조하는 형식이지만, 메모리상에서 프로세스가 실행되기 위해서는 가상주소는 반드시 실주소로 변환되야 하며, 이를 __`사상(Mapping)`__ 이라고 부름
- 사상이 빨리 수행되지 않으면 가상주소가 실주소로 빨리 변환되지 못해 프로세스의 실행이 제대로 되지 않을 수 있기 때문에 가상주소와 실주소 간의 연관이 효율적으로 이루어져야 함

​    

### 블록 단위 주소 변환

- __`동적 주소 변환(Dynamic Address Translation)`__ 은 __프로세스의 런타임 시점에 가상주소가 실주소로 바뀌는 절차가 실행되는 것을 의미함__
- 만일 가상 메모리상의 위치가 실제 메모리의 어느 곳에 위치하는 지를 알고 싶으면 보통 __`주소 변환 사상표(Address Translation Mapping Table)`__ 을 유지해야 하며, 보통 이러한 사상표는 효율적인 정보 관리를 위해 정보를 __`블록(Block)`__ 이라는 단위로 분류함
- 즉, 정보를 블록 단위로 분류하고 각 블록이 메인 메모리의 어느 위치를 나타내는 지를 사상표로 관리하는 것
- 블록의 크기가 동일할 경우에는 __`페이지(Page)`__ 라는 개념을 사용하며, 페이지 단위의 가상메모리 구성을 __`페이징(Paging)`__ 기법이라고 부름
- 블록의 크기가 다를 경우에는 __`세그먼트(Segment)`__ 라는 개념을 사용하며, 세그먼트 단위의 가상메모리 구성을 __`세그먼테이션(Segmentation)`__ 이라고 부름

​    

### 페이징 기법

- 가상메모리를 고정된 크기의 블록인 페이지(Page) 단위로 나누어 관리하며 보통 v = (p,d) 와 같은 식으로 나타냄

  - 여기서 p는 페이지 번호를, d는 p로부터의 페이지 변위를 의미함

- 프로세스가 실행되기 위해 특정 페이지를 참조하고자 한다면, 해당 페이지는 메모리에 반드시 위치해야 함

- 이를 위해 실 메모리 영역 또한 가상 메모리와 동일하게 고정된 크기의 블록으로 나뉘어야 하는데, 여기서 동일하게 나뉜 각 블록을 페이지 __`프레임(Page Frame)`__ 이라고 부름

  - 다시 말해, 가상 메모리의 페이지 개념을 반영할 수 있도록 실 메모리에도 동일한 틀을 만들어 둔 것
  - 이후 페이지는 비어있는(가용 상태의) 페이지 프레임 아무 곳에나 적재하면 됨

- 이후 __`페이지 사상표(Mapping Table)`__ 라는 것을 사용해서 프로세스가 사용하는 가상주소를 메모리에 적재된 후에도 바로 찾을 수 있도록 실주소로 동적 변환함

- 사상표에는 페이지 번호에 대한 실주소의 페이지 프레임 번호가 저장되있으며, 해당 페이지가 메모리에 존재하는 지 여부를 나타내는 비트값도 가지고 있음

- 이런 식으로 페이지 사상표를 직접 이용해서 동적 주소 변환을 하는 것을 __`직접 사상`__ 이라고 함

- 페이지 변환 정보를 연관기억장치에 저장한 연관 사상표를 이용하여 동적 변환을 할 경우에는 __`연관 사상`__ 이라고 함

  - 연관기억장치는 저장된 값을 이용해서 데이터에 액세스하는 고속 메모리 장치를 말함

- 보통은 연관사상과 직접 사상을 같이 사용하며, 연관 사상표에는 가장 최근에 참조된 페이지 항목을 보관하고 나머지는 페이지 사상표에 수록해서 연관 사상표에 없는 경우에는 직접 사상을 적용하는 식으로 구현

- 한편, 메모리가 동일 크기의 페이지 프레임으로 나뉘며, 메모리 보호도 페이지 단위로 이루어지기 때문에 페이징 기법에서 __`외부 단편화`__ 는 발생하지 않음

- 하지만 개별 페이지에 대해 작은 크기의 공간들이 여전히 생길 수 있기 때문에 __`내부 단편화`__ 문제는 계속 존재함

  

### 세그멘테이션 기법

- 가상주소 v를 순서쌍 (s,d) 로 나타내며 앞서 언급한대로 세그멘테이션에서는 블록의 크기가 고정되있지 않음
  - 여기서 s는 세그먼트 번호를 나타내고, d는 세그먼트 s의 시작위치로부터의 변위를 나타냄
- 논리적 단위에 해당하는 각각의 세그먼트는 각자의 이름과 길이를 가지게 되고, 사용자가 이를 지정함으로써 주소가 특정되는 것
- 세그멘트를 메모리에 적재하기 위해서는, 이를 수용할 수 있을 만큼 충분히 큰 메모리의 사용 가능한 영역에 배치하면 되며, 세그멘테이션 기법의 위치 지정 방식은 최초적합, 최적적합 등의 방법과 동일함
- 동적 주소 변환을 할 경우에는 페이징 기법과 마찬가지로 __`세그먼트 사상표`__ 라는 것을 통해, 가상주소의 세그멘트 번호에 대한 실주소에서의 시작 위치를 찾아 주소를 변환함
  - 세그멘트 사상표에는 또한 세그멘트가 현재 메모리에 존재하는 지 여부를 나타내는 비트값, 보조기억장치에서의 위치정보, 세그멘트 길이 등도 같이 저장됨
- 세그멘테이션 기법을 적용할 경우에는 블록의 크기가 고정되있지 않기 때문에 페이징 기법의 한계인 __내부 단편화 문제를 해결__ 할 수 있지만, 동시에 __외부 단편화 문제가 발생할 수 있다는 한계가 있음__
  - 세그먼트의 크기는 각 프로세스에 필요한 양에 따라 상이하기 때문에 불필요하게 더 많은 공간을 할당받는 경우가 없기 때문에 내부 단편화가 발생하지 않음
  - 하지만 서로 상이한 크기의 메모리가 할당되고 해제되는 과정이 반복되다 보면, 중간에 작은 크기의 공간들이 발생하므로 외부 단편화 문제가 발생할 수 있는 것

​    

### 페이지 호출 기법

>  페이지를 어느 시점에 메모리에 적재할 지를 결정하는 기법

- __`요구 페이지 호출`__ :페이지가 요구될 때 주기억장치로 옮기는 것
  - 각 페이지는 실행중인 프로세스에 의해 명백하게 참조될 경우에만 보조기억장치에서 메모리로 옮겨지는 것
  - 어느 페이지를 주기억장치로 옮길 지 결정하는 데 있어서의 오버헤드가 최소화되며, 옮겨진 페이지는 모두 프로세스에 의해 실제로 참조됨을 확신할 수 있음
- __`예상 페이지 호출`__ : 필요한 페이지를 예상하여 미리 페이지를 주기억장치에 옮기는 것
  - 곧 사용될 것으로 예상되는 페이지를 미리 옮겼기 때문에, 이것이 실제로 필요한 시점이 되었을 때는 바로 사용할 수 있으므로 그만큼 실행시간이 단축됨
  - 요구 페이지 호출을 적용했을 때, 필요한 시점에 페이지가 메모리에 없어 실행이 지연되는 __`페이지 부재(page fault)`__ 문제를 극복할 수 있음
  - 하지만 예상이 잘못될 경우에는 오히려 메모리 공간을 낭비할 수 있는 위험 또한 존재함

​    

### 페이지 교체 기법

>  페이징 기법에는 모든 페이지 프레임이 사용되고 있는 것이 일반적이며, 이럴 경우 운영체제는 메모리에 새로 적재해야 할 페이지를 위해 적절히 교체 대상이 될 페이지 프레임을 선택해서 이를 보조기억장치에 보관해야 함

- __`최적화 원칙`__ : 최적의 성과를 얻고자 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체 대상으로 선택하는 것

  - 하지만 이론적으로 최적이나 미래를 쉽게 예측할 수 없기 때문이 사실상 실현은 불가능함
  - 따라서 이 기법은 다른 페이지 교체 기법이 얼마나 최적성을 갖고 잇는 지를 비교하는 데 사용됨
  - 보통 페이지 교체 기법을 선택할 때는 교체 대상을 선택하기 위한 시간 및 공간에 대한 오버헤드가 최대한 적은 것을 선택하는 것이 좋음

- __`FIFO 페이지 교체`__ : 각 페이지가 메모리에 적재될 때마다 그 때의 시간을 기억해뒀다가, 페이지를 교체할 때 메모리 내에서 가장 오래 존재했던 페이지를 교체 대상으로 선택

  - __`Belady의 이상현상`__ : 프로세스에 더 많은 수의 페이지 프레임을 할당할 때 오히려 페이지 부재가 더 많이 발생하는 현상으로 FIFO 기법에서는 교체한 페이지가 이후에 바로 적재 대상이 되버리는 상황이 발생할 수 있음

- __`LRU 페이지 교체`__ : 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체하는 전략으로, 최근의 상황이 가까운 미래를 예측하기 위한 좋은 척도라는 것을 전제로 함

  - 이러한 전제를 __`국부성 휴리스틱`__ 이라고 부르는데, 여기서 '국부성'은 다른 의미로 __`지역성(locality)` __ 을 나타내며 프로세스가 기억장치 내의 정보를 균일하게 액세스하는 것이 아닌 어느 한 순간에 특정 부분을 집중적으로 참조함__ 을 의미함
  - 시간적 측면에서는 처음 참조된 곳이 가까운 미래에도 계속 참조될 가능성이 높고, 공간적 측면에서는 하나의 장소가 참조되면 그 근처의 장소가 계속 참조되는 경향이 있음을 말하는 것
  - LRU는 앞서 말한 FIFO 기법을 사용했을 때 Belady의 이상현상이 발생할 수 있는 한계를 극복할 수 있지만, 매번 시간을 기록하고 가장 오래된 참조시간을 탐색하거나 페이지 번호를 저장하는 리스트를 유지하기 위한 오버헤드가 발생한다는 단점이 있음

- __`LFU 페이지 교체`__ : LRU와 유사하지만, 여기서는 각 페이지가 __얼마나 많이 사용되었는 지__ 를 기준으로 참조 횟수가 가장 적은 페이지를 교체대상으로 선택하는 기법

  - 가장 적게 사용되는 페이지가 오히려 최근에 메모리에 적재된 것일 가능성이 있다는 점에서 LFU 또한 완벽한 최적성을 보장할 수 없음
  - 초기에 매우 많이 사용된 후 더 이상 사용되지 않는 페이지의 경우에도 전반적인 참조 횟수로 인해 교체 대상에서 제외되므로 불필요하게 오랫동안 메모리를 점유할 수도 있음
  - 마찬가지로 LRU와 비슷하게 교체 대상을 가리기 위한 오버헤드가 큼

- __`NUR 페이지 교체`__ : LRU와 유사하게 정해진 기준에 따라 우선순위가 높은 페이지를 교체 대상으로 삼는 기법으로 더 적은 오버헤드로 적절한 성능을 낼 수 있는 기법

  - 페이지들을 참조 여부와 수정 여부에 따라 아래와 같이 4개의 집단으로 나눈 후 집단 1->4의 순서로 교체대상이 될 집단을 선택하며, 집단 내에서는 무작위로 페이지를 선택

  | 그룹 | r(참조비트) | m(수정비트) | 비고                               |
  | :--: | ----------- | ----------- | ---------------------------------- |
  |  1   | 0           | 0           | 참조, 수정 둘 다 되지 않음         |
  |  2   | 0           | 1           | 참조되지 않았으나 수정된 적이 있음 |
  |  3   | 1           | 0           | 참조된 적은 있으나 수정되지 않음   |
  |  4   | 1           | 1           | 참조와 수정 둘 다 된 적이 있음     |

  