# 가상메모리

### 메모리(Memory)?

- 메모리는 프로그램과 프로그램 실행에 필요한 데이터 및 코드를 저장하는 장치를 의미함(하드웨어적 측면)
- 메모리는 컴퓨터 구조에서 크게 내부 기억장치에 해당하는 __`주기억장치(Main Memory)`__ 와 외부 기억장치에 해당하는 __`보조기억장치`__ 로 나눠볼 수 있음
  - RAM, CPU 내부의 레지스터(Register)와 캐시(Cache)가 주기억장치에 해당됨
  - SSD, HDD 등은 보조기억장치에 해당됨
  - 보통 CPU에 가까울 수록 접근 속도가 빠르지만, 그만큼 비용이 비싸고 용량이 적다는 특징이 있음

​    

### 가상메모리(Virtual Memory)?

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/6/6e/Virtual_memory.svg/220px-Virtual_memory.svg.png)

- 컴퓨터 시스템의 메모리 크기보다 더 큰 크기를 가지는 프로세스를 실행하기 위해 사용하는 방법
  - 일반적으로 여러 프로세스는 CPU와 메인 메모리 자원을 공유하는데, 보통 CPU의 경우에는 자원 할당 순서를 기다리는 과정에서 느려지는 상황을 고려하지 이외의 심각한 오류를 고려하진 않음
  - 하지만 메모리 자원의 경우에는 여러 프로세스로부터 지나치게 많은 요구가 있을 경우 프로그램의 논리와 무관하게 공간적인 여유가 없는 것으로 인해 오류가 발생할 수 있음
  - 따라서 가상메모리를 통해 실제로 이용 가능한 메모리를 논리적으로 추상화하여 사용자에게는 마치 실제 메모리처럼 보이게 하고 실제로는 모든 메모리 영역을 할당하지는 않는 것
  - 단순하게 생각하면 __가상 메모리는 메모리가 실제 메모리 공간보다 많아 보이게 함으로써, 프로세스가 실행될 때 프로세스 전체가 메모리에 올라가는 것이 아닌 당장 필요한 부분만 메모리에 올리는 것__ 으로 이해하면 됨

- __`오버레이 기법`__ : 가상메모리 사용 이전에 메모리 부족 문제를 해결하기 위해 사용했던 기법으로, __사용자가 프로그램의 일부분만 메모리에 올려 실행하도록 지정할 수 있게 하는 것__
  - 오버레이 기법이 적용된 프로그램은 메모리를 실제로 덜 사용하는 이점이 있었지만, 이 역시 근본적으로는 프로그램의 일부분만 올리더라도 이를 위한 충분한 메모리 공간을 갖추지 않을 경우에는 비슷하게 메모리 부족으로 인한 오류가 발생한다는 한계가 있었음
  - 가상메모리는 여기서 한단계 더 나아간 것으로 프로그램 실행을 위해 단순히 얼마나 많은 공간이 필요한 가에 집중하지 않고, __프로그램 실행을 위해 최소한 얼마만큼의 공간이 필요한가에 집중한 것__

- 가상메모리 기법은 __프로그램을 실행할 때, 당장 필요한 부분만 메인 메모리에 올리고 필요하지 않은 나머지 부분은 보조 기억장치에 올려두는 방식__
  - 이는 다시 말해 접근 속도가 빠른 RAM과, 상대적으로 속도가 느린 보조 기억장치를 하나로 묶어 마치 하나의 단일한 기억장치처럼 동작하도록 보이게 하는 것
  - 논리적으로는 하나이지만, 실제로는 두 개 이상의 기억장치가 관여하기 때문에 가상(virtual)이란 단어를 사용하는 것!

- 프로그램에는 메모리의 __`실주소(Physical Address)`__ 가 아닌, __`가상주소(Virtual Address)`__ 가 부여되며 실행중인 프로세스가 참조하는 가상주소의 범위는 프로세스의 __`가상주소 공간(Virtual Address Space)`__ 라고 부르고, 사용 가능한 실주소의 범위는 __`실주소 공간(Real Address Space)`__ 이라고 부름
- 언급한대로 프로세스는 오직 가상주소만을 참조하는 형식이지만, 메모리상에서 프로세스가 실행되기 위해서는 가상주소는 반드시 실주소로 변환되야 하며, 이를 __`사상(Mapping)`__ 이라고 부름
- 사상이 빨리 수행되지 않으면 가상주소가 실주소로 빨리 변환되지 못해 프로세스의 실행이 제대로 되지 않을 수 있기 때문에 가상주소와 실주소 간의 연관이 효율적으로 이루어져야 함

​    

### 블록 단위 주소 변환

- __`동적 주소 변환(Dynamic Address Translation)`__ 은 __프로세스의 런타임 시점에 가상주소가 실주소로 바뀌는 절차가 실행되는 것을 의미함__
- 만일 가상 메모리상의 위치가 실제 메모리의 어느 곳에 위치하는 지를 알고 싶으면 보통 __`주소 변환 사상표(Address Translation Mapping Table)`__ 을 유지해야 하며, 보통 이러한 사상표는 효율적인 정보 관리를 위해 정보를 __`블록(Block)`__ 이라는 단위로 분류함
- 즉, 정보를 블록 단위로 분류하고 각 블록이 메인 메모리의 어느 위치를 나타내는 지를 사상표로 관리하는 것
- 블록의 크기가 동일할 경우에는 __`페이지(Page)`__ 라는 개념을 사용하며, 페이지 단위의 가상메모리 구성을 __`페이징(Paging)`__ 기법이라고 부름
- 블록의 크기가 다를 경우에는 __`세그먼트(Segment)`__ 라는 개념을 사용하며, 세그먼트 단위의 가상메모리 구성을 __`세그먼테이션(Segmentation)`__ 이라고 부름

​    

### 페이징 기법

- 가상메모리를 고정된 크기의 블록인 페이지(Page) 단위로 나누어 관리하며 보통 v = (p,d) 와 같은 식으로 나타냄

  - 여기서 p는 페이지 번호를, d는 p로부터의 페이지 변위를 의미함

- 프로세스가 실행되기 위해 특정 페이지를 참조하고자 한다면, 해당 페이지는 메모리에 반드시 위치해야 함

- 이를 위해 실 메모리 영역 또한 가상 메모리와 동일하게 고정된 크기의 블록으로 나뉘어야 하는데, 여기서 동일하게 나뉜 각 블록을 페이지 __`프레임(Page Frame)`__ 이라고 부름

  - 다시 말해, 가상 메모리의 페이지 개념을 반영할 수 있도록 실 메모리에도 동일한 틀을 만들어 둔 것
  - 이후 페이지는 비어있는(가용 상태의) 페이지 프레임 아무 곳에나 적재하면 됨

- 이후 __`페이지 사상표(Mapping Table)`__ 라는 것을 사용해서 프로세스가 사용하는 가상주소를 메모리에 적재된 후에도 바로 찾을 수 있도록 실주소로 동적 변환함

- 사상표에는 페이지 번호에 대한 실주소의 페이지 프레임 번호가 저장되있으며, 해당 페이지가 메모리에 존재하는 지 여부를 나타내는 비트값도 가지고 있음

- 이런 식으로 페이지 사상표를 직접 이용해서 동적 주소 변환을 하는 것을 __`직접 사상`__ 이라고 함

- 페이지 변환 정보를 연관기억장치에 저장한 연관 사상표를 이용하여 동적 변환을 할 경우에는 __`연관 사상`__ 이라고 함

  - 연관기억장치는 저장된 값을 이용해서 데이터에 액세스하는 고속 메모리 장치를 말함

- 보통은 연관사상과 직접 사상을 같이 사용하며, 연관 사상표에는 가장 최근에 참조된 페이지 항목을 보관하고 나머지는 페이지 사상표에 수록해서 연관 사상표에 없는 경우에는 직접 사상을 적용하는 식으로 구현

- 한편, 메모리가 동일 크기의 페이지 프레임으로 나뉘며, 메모리 보호도 페이지 단위로 이루어지기 때문에 페이징 기법에서 __`외부 단편화`__ 는 발생하지 않음

- 하지만 개별 페이지에 대해 작은 크기의 공간들이 여전히 생길 수 있기 때문에 __`내부 단편화`__ 문제는 계속 존재함

  

### 세그멘테이션 기법

- 가상주소 v를 순서쌍 (s,d) 로 나타내며 앞서 언급한대로 세그멘테이션에서는 블록의 크기가 고정되있지 않음
- 논리적 단위에 해당하는 각각의 세그먼트는 각자의 이름과 길이를 가지게 되고, 사용자가 이를 지정함으로써 주소가 특정되는 것
- 세그멘트를 메모리에 적재하기 위해서는, 이를 수용할 수 있을 만큼 충분히 큰 메모리의 사용 가능한 영역에 배치하면 되며, 세그멘테이션 기법의 위치 지정 방식은 최초적합, 최적적합 등의 방법과 동일함
- 동적 주소 변환을 할 경우에는 페이징 기법과 마찬가지로 __`세그먼트 사상표`__ 라는 것을 통해, 가상주소의 세그멘트 번호에 대한 실주소에서의 시작 위치를 찾아 주소를 변환함
  - 세그멘트 사상표에는 또한 세그멘트가 현재 메모리에 존재하는 지 여부를 나타내는 비트값, 보조기억장치에서의 위치정보, 세그멘트 길이 등도 같이 저장됨
- 세그멘테이션 기법을 적용할 경우에는 블록의 크기가 고정되있지 않기 때문에 페이징 기법의 한계인 __내부 단편화 문제를 해결__ 할 수 있지만, 동시에 __외부 단편화 문제가 발생할 수 있다는 한계가 있음__
  - 세그먼트의 크기는 각 프로세스에 필요한 양에 따라 상이하기 때문에 불필요하게 더 많은 공간을 할당받는 경우가 없기 때문에 내부 단편화가 발생하지 않음
  - 하지만 서로 상이한 크기의 메모리가 할당되고 해제되는 과정이 반복되다 보면, 중간에 작은 크기의 공간들이 발생하므로 외부 단편화 문제가 발생할 수 있는 것

​    


​    